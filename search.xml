<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA与C、C++的区别</title>
    <url>/2020/02/28/JAVA%E4%B8%8EC%E3%80%81C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Java与C、C-的10大区别"><a href="#Java与C、C-的10大区别" class="headerlink" title="Java与C、C++的10大区别"></a>Java与C、C++的10大区别</h1><p>  首先应该清楚，Java 是由 C++发展而来的，保留了 C++的大部分内容，其编程方式类似于 C++。但 Java 的句法更清晰、规模更小、更易学。Sun 公司曾对多种程序设计语言进行分析研究，取其精华去其糟粕，最终推出了 Java。Java从根本上解决了C++的固有缺陷，形成了新一代面向对象的程序设计语言。</p>
<a id="more"></a>

<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/539392/1576821979686-65d43364-c71b-4d10-be86-1500eaef0647.jpeg#align=left&display=inline&height=375&originHeight=375&originWidth=640&size=0&status=done&style=none&width=640" alt><br>Java 和 C/C++的相似之处多于不同之处，有 C 基础的读者，学习 Java 会更容易。相较而言，Java 的编程环境更为简单。在此，给大家列举以下Java与C/C++之间的区别之处。</p>
<h2 id="一、指针"><a href="#一、指针" class="headerlink" title="一、指针"></a>一、指针</h2><p><strong>Java 没有指针的概念。</strong>在 C/C++中，指针操作内存时，经常会出现错误。而在Java中是没有指针这一概念的，因此也有效地防止了一系列由指针引起的操作层失误（如指针悬空所造成的系统崩溃），更有利于 Java 程序的安全。</p>
<h2 id="二、多重继承"><a href="#二、多重继承" class="headerlink" title="二、多重继承"></a>二、多重继承</h2><p><strong>Java不支持多重继承。</strong>多重继承，它允许多父类派生一个子类。也就是说，一个类允许继承多个父类。尽管多重继承功能很强，但使用复杂，而且会引起许多麻烦，编译程序实现它也很不容易。所以 Java 不支持多重继承，但允许一个类实现多个接口。可见，Java 既保留了 C++多重继承的功能，又避免了 C++的许多缺陷。</p>
<h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h2><p><strong>Java 是完全面向对象的语言</strong>，所有方法和数据都必须是<strong>类</strong>的一部分。除了<strong>基本数据类型</strong>之外，其余类型的数据都作为<strong>对象型数据</strong>。例如，对象型数据包括字符串和数组。类将数据和方法结合起来，把它们封装在其中，这样每个对象都可实现具有自己特点的行为。而 C++将函数和变量定义为全局的，然后再来调用这些函数和变量，从而增加了程序的负担。此外，Java 还取消了 C/C++中的结构和联合，使编译程序更加简洁。</p>
<h2 id="四、自动内存管理"><a href="#四、自动内存管理" class="headerlink" title="四、自动内存管理"></a>四、自动内存管理</h2><p><strong>Java 自动进行无用内存回收操作，不再需要程序员进行手动删除。</strong>Java 程序中所有的对象都是用 <strong>new 操作符</strong>建立在堆栈上的，这个操作符类似于 C++的“new”操作符。当 Java 中一个对象不再被用到时，无须使用内存回收器，只需要给它添加删除标签，无用内存的回收器便利用空闲时间在后台运行。而 C++中必须由程序释放内存资源，这就增加了程序员的负担。</p>
<h2 id="五、操作符重载"><a href="#五、操作符重载" class="headerlink" title="五、操作符重载"></a>五、操作符重载</h2><p><strong>Java 不支持操作符重载，操作符重载被认为是 C++的突出特征。</strong>操作符重载，就是把操作符(比如’+，-，<em>，/‘这些运算符)赋于新的意义， 来完成更为细致具体的运算等功能。要实现操作符重载，就要使用操作符重载函数，而运用函数就肯定会存在各种限制条件以及特殊情况。特殊情况就需特殊处理，因此操作符重载还是比较繁琐的。<br>而根据上述二、三两点，我们可以了解到Java语言是走“简洁风”的，因此为了保持Java语言的简洁性，便毅然抛弃了操作符重载这一功能，但是为了避免舍本逐末的情况，Java语言还是可以通过*</em>类<strong>来实现操作符重载所具有的功能的。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1576821979859-ac9757b5-ae06-4e56-b339-cc0e5775e2be.png#align=left&display=inline&height=371&originHeight=371&originWidth=488&size=0&status=done&style=none&width=488" alt><br>**六、预处理功能</strong><br>C/C++在编译过程中都有一个预编译阶段，即预处理器。预处理器为开发人员提供了方便，但增加了编译的复杂性。Java 允许预处理，但不支持预处理器功能，因为 Java 没有预处理器，所以为了实现预处理，它提供了引入语句（import），但它与 C++预处理器的功能类似。<br><strong>七、缺省参数函数</strong><br><strong>Java 不支持缺省参数函数，而 C++支持</strong> <strong>。</strong>在 C 语言中，代码组织在函数中，函数可以访问程序的全局变量。后来<strong>C++增加了类</strong>，提供了类算法，该算法是与类相连的函数，C++类方法与 Java 类方法十分相似。由于 C++仍然支持 C语言，所以 C++程序中仍然可以使用 C 的函数，结果导致函数和方法混合使用，使得 C++程序混乱，而<strong>Java 没有函数。</strong>作为一个比 C++更纯的面向对象的语言，Java 强迫开发人员把所有<strong>例行程序包括在类中</strong>。事实上，用方法实现例行程序可激励开发人员更好地组织编码。<br><strong>八、字符串</strong><br><strong>C 和 C++不支持字符串变量</strong>，在 C 和 C++程序中使用<strong>“Null”终止符</strong>代表字符串的结束。在 Java 中字符串是用<strong>类对象</strong>（String 和 StringBuffer）来实现的，在整个系统中建立字符串和访问字符串元素的方法是一致的。Java 字符串类是作为 Java 语言的一部分定义的，而不是作为外加的延伸部分。此外，Java 还可以对字符串用“+”进行连接操作。<br><strong>九、goto 语句</strong><br>“可怕”的 goto 语句是 C 和 C++的“遗物”，它是该语言技术上的合法部分。goto语句也称为无条件转移语句，通常与条件语句配合使用，用来实现条件转移， 构成循环，跳出循环体等功能。但是，在结构化程序设计中一般不主张使用goto语句， 以免造成程序流程的混乱，使程序的可读性变差,增加程序调试的难度。 Java 不提供 goto 语句，虽然Java指定 goto 作为关键字，但不支持它的使用，这使程序更简洁易读。<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/539392/1576821979788-eab034e5-5456-4de8-bf32-b88ded3ab233.jpeg#align=left&display=inline&height=415&originHeight=415&originWidth=392&size=0&status=done&style=none&width=392" alt><br><strong>十、类型转换</strong><br>在 C 和 C++中，有时会出现数据类型的隐含转换，这就涉及了自动强制类型转换问题。例如，在 C++中可将一个浮点值赋予整型变量，并去掉其尾数。Java 不支持 C++中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。</p>
]]></content>
      <categories>
        <category>java语法</category>
      </categories>
      <tags>
        <tag>java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA关键字</title>
    <url>/2020/02/28/JAVA%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h3 id="关键字-1"><a href="#关键字-1" class="headerlink" title="关键字"></a>关键字</h3><p><img src="/2020/02/28/JAVA%E5%85%B3%E9%94%AE%E5%AD%97/1.png" alt="img"></p>
 <a id="more"></a>

<p>一）总表：java关键字共53个（其中包含两个保留字const，goto）</p>
<p><strong>abstract assert boolean break byte case catch char class const continue    default    do    double    else</strong><br><strong>enum    extends    final    finally    float for    goto    if    implements    import instanceof    int    interface    long    native</strong><br><strong>new    package    private    protected    public return    strictfp    short    static    super switch    synchronized    this    throw    throws</strong><br>*<em>transient    try    void    volatile    while true    false    null    *</em></p>
<p>（二）大致含义<br>      关键字                          含义</p>
<ol>
<li>abstract    表明类或者成员方法具有抽象属性</li>
<li>assert    断言，用来进行程序调试</li>
<li>boolean    基本数据类型之一，布尔类型</li>
<li>break    提前跳出一个块</li>
<li>byte    基本数据类型之一，字节类型</li>
<li>case    用在switch语句之中，表示其中的一个分支</li>
<li>catch    用在异常处理中，用来捕捉异常</li>
<li>char    基本数据类型之一，字符类型</li>
<li>class    声明一个类</li>
<li>const    保留关键字，没有具体含义</li>
<li>continue    回到一个块的开始处</li>
<li>default    默认，例如，用在switch语句中，表明一个默认的分支</li>
<li>do    用在do-while循环结构中</li>
<li>double    基本数据类型之一，双精度浮点数类型</li>
<li>else    用在条件语句中，表明当条件不成立时的分支</li>
<li>enum    枚举</li>
<li>extends    表明一个类型是另一个类型的子类型，这里常见的类型有类和接口</li>
<li>final    用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</li>
<li>finally    用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</li>
<li>float    基本数据类型之一，单精度浮点数类型</li>
<li>for    一种循环结构的引导词</li>
<li>goto    保留关键字，没有具体含义</li>
<li>if    条件语句的引导词</li>
<li>implements    表明一个类实现了给定的接口</li>
<li>import    表明要访问指定的类或包</li>
<li>instanceof    用来测试一个对象是否是指定类型的实例对象</li>
<li>int    基本数据类型之一，整数类型</li>
<li>interface    接口</li>
<li>long    基本数据类型之一，长整数类型</li>
<li>native    用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</li>
<li>new    用来创建新实例对象</li>
<li>package    包</li>
<li>private    一种访问控制方式：私用模式</li>
<li>protected    一种访问控制方式：保护模式</li>
<li>public    一种访问控制方式：共用模式</li>
<li>return    从成员方法中返回数据</li>
<li>short    基本数据类型之一,短整数类型</li>
<li>static    表明具有静态属性</li>
<li>strictfp    用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 [1] </li>
<li>super    表明当前对象的父类型的引用或者父类型的构造方法</li>
<li>switch    分支语句结构的引导词</li>
<li>synchronized    表明一段代码需要同步执行</li>
<li>this    指向当前实例对象的引用</li>
<li>throw    抛出一个异常</li>
<li>throws    声明在当前定义的成员方法中所有需要抛出的异常</li>
<li>transient    声明不用序列化的成员域</li>
<li>try    尝试一个可能抛出异常的程序块</li>
<li>void    声明当前成员方法没有返回值</li>
<li>volatile    表明两个或者多个变量必须同步地发生变化</li>
<li>while    用在循环结构中</li>
</ol>
<h1 id="访问控制关键字"><a href="#访问控制关键字" class="headerlink" title="访问控制关键字"></a>访问控制关键字</h1><p>1、public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用<br>2、private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用。<br>3、protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。<br>4、friendly权限是java的默认权限，也称作包（package）访问权限，只要不加private、public、protect的就是friendly访问权限，所有的成员仅限同一个包内的成员访问（当然包含自己）。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1576733250856-780aa2b9-3b0f-4925-8e5f-630aa7e3f2db.png#align=left&display=inline&height=142&originHeight=142&originWidth=600&size=0&status=done&style=none&width=600" alt><br>5、default<br>总的来说，<code>default</code>的用法不多，只有两种:<br>在<code>switch</code>语句的时候使用<code>default</code><br>在定义接口的时候使用<code>default</code>来修饰具体的方法</p>
<h1 id="类、方法和变量修饰符"><a href="#类、方法和变量修饰符" class="headerlink" title="类、方法和变量修饰符"></a>类、方法和变量修饰符</h1><table>
<thead>
<tr>
<th>abstract</th>
<th>声明抽象</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>类</td>
</tr>
<tr>
<td>extends</td>
<td>扩充,继承</td>
</tr>
<tr>
<td>final</td>
<td>最终值,不可改变的</td>
</tr>
<tr>
<td>implements</td>
<td>实现（接口）</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td>native</td>
<td>本地，原生方法（非 Java 实现）</td>
</tr>
<tr>
<td>new</td>
<td>新,创建</td>
</tr>
<tr>
<td>static</td>
<td>静态</td>
</tr>
<tr>
<td>strictfp</td>
<td>严格,精准</td>
</tr>
<tr>
<td>synchronized</td>
<td>线程,同步</td>
</tr>
<tr>
<td>transient</td>
<td>短暂</td>
</tr>
<tr>
<td>volatile</td>
<td>易失</td>
</tr>
</tbody></table>
<h2 id="abstract："><a href="#abstract：" class="headerlink" title="abstract："></a>abstract：</h2><p>用abstract修饰的类，即抽象类；</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>** 抽象类（abstract）的使用：**当父类的某些方法不确定时，可以用abstract关键字来修饰该方法[抽象方法]，用abstract来修饰该类[抽象类]。</p>
<ul>
<li>用abstract关键字来表达的类，其表达形式为：（public）abstract class 类名{}</li>
<li>抽象类不能被直接实例化，也就是说我们没法直接new 一个抽象类。抽象类本身就代表了一个类型，无法<br>确定为一个具体的对象，所以不能实例化就合乎情理了，只能有它的继承类实例化。</li>
<li>抽象类中不一定要包含abstract方法。也就是了，抽象中可以没有abstract方法，但是一旦类中包含了abstract方法，那类该类必须声明为abstract类。</li>
<li>抽象类虽然不能被实例化，但可以有自己的构造方法（如果我们不写，编译器会自动默认一个无参构造方法）</li>
<li>和普通的继承类一样，在new 一个子类对象时会优先调用父类（抽象父类）的构造器初始化，然后再调用子类的构造器。</li>
<li>对于抽象类中的非statci(静态)和非abstract(抽象)方法中的this关键字（静态方法中不能有关键字this）代表的是它的继承类，而非抽象类本身，这个好理解，因为抽象类本身不能被实例化。如果有多个继承类，谁调用this就代表谁。</li>
<li>抽象类与接口（interface）有很大的不同之处，接口中不能有实例方法去实现业务逻辑，而抽象类<br>中可以有实例方法，并实现业务逻辑，比如我们可以在抽象类中创建和销毁一个线程池。</li>
<li>抽象类不能使用final关键字修饰，因为final修饰的类是无法被继承，而对于抽象类来说就是<br>需要通过继承去实现抽象方法，这又会产生矛盾。</li>
</ul>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul>
<li>用abstract修饰的方法，即抽象方法。抽象方法不能有方法主体。格式如下：abstract void xxx();所以抽象方法跟普通方法是有区别的，它没有自己的主体（没有{}包起来的业务逻辑），跟接口中的方法有点类似。所以我们没法直接调用抽象方法</li>
<li>抽象方法不能用private修饰，因为抽象方法必须被子类实现（覆写），而private权限对于子类来<br>说是不能访问的，所以就会产生矛盾</li>
<li>抽象方法也不能用static修饰，如果用static修饰了，那么可以直接通过类名调用，而抽象方法压根就没有主体，没有任何业务逻辑，没法直接调用抽象方法，因为这样毫无意义。</li>
<li>抽象类可以被继承，但是 当继承的父类是抽象类时，需要将抽象类中的所有抽象方法全部实现。也就是说如果一个类继承了一个抽象类，那么它必须全部覆写抽象类中的抽象方法，当然也可以不全部覆写，如果<br>不覆写全部抽象方法则这个子类也必须是抽象类。</li>
</ul>
<h3 id="抽象类和方法的作用"><a href="#抽象类和方法的作用" class="headerlink" title="抽象类和方法的作用"></a>抽象类和方法的作用</h3><ul>
<li>当多个类中出现了相同的功能，但是功能主体不同这是可以进行向上提取的。这时，只提取功能定义，而不抽取功能主体，所以，抽象类是为了把相同的但不确定的东西的提取出来，为了以后的重用。定义成抽象类的目的，就是为了在子类中实现抽象类。</li>
<li>由于抽象类不能被实例化，最大的好处就是通过方法的覆盖来实现多态的属性。也就是运行期绑定</li>
<li>抽象类将事物的共性的东西提取出来，由子类继承去实现，代码易扩展、易维护。</li>
</ul>
<hr>
<h2 id="classs"><a href="#classs" class="headerlink" title="classs"></a>classs</h2><hr>
<h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><ul>
<li><p>父类也叫基类、超类</p>
</li>
<li><p>子类也叫派生类</p>
</li>
<li><p>在继承的而关系中，<strong>“**</strong>子类就是一个父类<strong>**“</strong>。也就是说，子类可以被当做父类来看待。例如<strong>父类是员工，子类是老师</strong>，那么我们可以说<strong>”老师就是一个员工“</strong>。</p>
</li>
<li><p><strong>关系是“is - a”</strong>，例如“<strong>老师 is a 员工</strong>”</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1576806472087-b5024af5-9667-4f88-8af6-d2e2e10031ad.png#align=left&display=inline&height=256&originHeight=296&originWidth=673&size=0&status=done&style=none&width=583" alt><br>1.1成员变量<br>类变量从该类的准备阶段起开始存在，直到系统完全销毁这个类，类变量的作用域与这个类的生存范围相同；</p>
<p>而实例变量则从该类的实例被创建起开始存在，直到系统完全销毁这个实例，实例变量的作用域与对应实例的生存范围相同。</p>
<p>正是基于这个原因，可以把类变量和实例变量统称为成员变量。其中类变量可以理解为类成员变量，它作为类本身的一个成员，与类本身共存亡；实例变量则可以理解为实例成员变量，它作为实例的一个成员与实例共存亡。</p>
<p>只要类存在，类就可以访问类变量         类.类变量</p>
<p>只要实例存在，实例就可以访问实例变量        实例.实例变量</p>
<p>当然实例也可以访问类变量。但是需要注意的是因为实例不拥有类变量，所以通过实例来访问类变量进行操作，实际上是对类变量进行操作 ，当有其他实例来访问类变量时，访问的类变量是被对象访问操作过的类变量。</p>
<p>成员变量无需显示初始化，只要为一个类定义了类变量或实例变量，系统就会在这个类的准备阶段或创建该类的实例时进行默认初始化。</p>
<p>1.2局部变量</p>
<p>局部变量根据定义形式的不同，又可以分为如下三种：</p>
<p>形参：在定义方法签名时定义的变量，形参的作用域在整个方法中都有效</p>
<p>方法局部变量：在方法体内定义的局部变量，它的作用域是从定义该变量的地方生效，到该方法结束时失效</p>
<p>代码块局部变量：这个局部变量的作用域从定义该变量的地方生效，到该代码结束时失效。</p>
<p>一个变量只在一对{}中起作用。。</p>
<p>java允许局部变量和成员变量同名，如果方法中局部变量和成员变量同名，局部变量就会覆盖成员变量，如果需要在这个方法中引用被覆盖成员变量，则可使用<strong>this（对于实例变量）</strong>或类名（对于类变量）作为调用者来限定访问成员变量。</p>
<h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><h4 id="定义父类的格式：-一个普通的类定义"><a href="#定义父类的格式：-一个普通的类定义" class="headerlink" title="定义父类的格式：(一个普通的类定义)"></a>定义父类的格式：(一个普通的类定义)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 父类名称</span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义子类的格式"><a href="#定义子类的格式" class="headerlink" title="定义子类的格式"></a>定义子类的格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类名称 <span class="keyword">extends</span> 父类名称</span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承中成员变量的访问特点"><a href="#继承中成员变量的访问特点" class="headerlink" title="继承中成员变量的访问特点"></a>继承中成员变量的访问特点</h3><h3 id="成员变量之间的访问-变量不重名的情况"><a href="#成员变量之间的访问-变量不重名的情况" class="headerlink" title="成员变量之间的访问 (变量不重名的情况)"></a>成员变量之间的访问 (变量不重名的情况)</h3><p><strong>先创立一个父类Fu</strong><br>public class Fu {<br>   public int numFu = 10;  //关键字为public，可以直接通过（对象.变量名）访问，方便说明问题<br>}<br><strong>再创立一个子类Zi</strong><br>public class Zi extends Fu{<br>   public int numZi = 20;<br>}<br>** 在main中分别建立父类和子类的对象**<br>public class Demo02ExtendsField {<br>   public static void main(String[] args) {<br>       //创建父类对象<br>       Fu fu = new Fu();<br>       //父类只能找到自己的成员numFu，并没有找到子类的成员numZi<br>       System.out.println(fu.numFu);</p>
<pre><code>//创立一个子类对象
Zi zi = new Zi();
//子类对象既可以打印父类的成员numFu，也可以打印自己的成员numZi
//还是那句&quot;先人不知道后人的事情，而后人知道先人的事情&quot;
System.out.println(zi.numFu);
System.out.println(zi.numZi);</code></pre><p>   }<br>}</p>
<h4 id="成员变量之间的访问-变量重名的情况"><a href="#成员变量之间的访问-变量重名的情况" class="headerlink" title="成员变量之间的访问 (变量重名的情况)"></a>成员变量之间的访问 (变量重名的情况)</h4><p>有两种情况：</p>
<ul>
<li>直接通过对象访问成员变量：这情况等号左边是谁，就优先用谁，没有则向上找</li>
<li>间接通过成员方法访问成员变量，这情况<strong>该方法属于谁，就优先用谁，没有则向上找</strong></li>
</ul>
<p>假设现在父类 Fu 和子类 Zi 都有一个变量名叫num<br>Fu 类<br>public class Fu {<br>   public int num = 10;</p>
<p>   public void methodFu(){<br>       //这里打印的num，一定是本类的，不会再往下找子类的<br>       System.out.println(num);<br>   }<br>}<br>Zi类</p>
<p>public class Zi extends Fu{<br>   public int num = 20;</p>
<p>   public void methodZi(){<br>       //这里打印的num，如果本类有，就优先打印本类的，如果没有再往上找<br>       System.out.println(num);<br>   }<br>}</p>
<ul>
<li><strong>第一种情况：直接通过对象访问成员变量</strong></li>
</ul>
<p>等号左边是谁，就优先用谁，没有则向上找。Fu fu = new Zi();等号的左边是父类<br>public class Demo02ExtendsField {<br>   public static void main(String[] args) {<br>    // Zi zi = new Fu(); <strong>不能通过父类来构造子类，先人（父类）根本不知道后人（子类）长什么样子</strong><br>       Fu fu = new Zi(); //<strong>可以通过子类来构造父类，这时等号左边是父类(即按照实例化参照的类来判断)</strong><br>       System.out.println(fu.num);  //10，打印的是父类的num<br>   }<br>}</p>
<ul>
<li><strong>第二种情况：间接通过成员方法访问成员变量</strong></li>
</ul>
<p>public class Demo02ExtendsField {<br>   public static void main(String[] args) {</p>
<pre><code>Fu fu = new Fu();
Zi zi = new Zi();
//打印的是父类的num，因为该类没有继承其它类，他自己肯定有一个num，才能写出这个方法
fu.methodFu();  //父类的num 10，补充：没有fu.methodZi(), 先人不知道后人的方法
//如果子类有一个num，那就优先打印本类的，没有的话再往父类那里找
zi.methodZi();  //子类的num 20
//重点！**子类用的是父类的方法打印num，这就要看这个方法属于谁，是谁定义的这个方法**
//因为methodFu()这个方法是属于父类的，打印的当然就是父类的num
zi.methodFu();  //父类的num 10</code></pre><p>   }<br>}</p>
<h4 id="区分子类方法中的重名"><a href="#区分子类方法中的重名" class="headerlink" title="区分子类方法中的重名"></a>区分子类方法中的重名</h4><p>假如有好多个num，父类有一个，子类有两个，怎么才能正确地打印想要的那个num呢？<br><strong>父类</strong><br>public class Fu {<br>   public int num = 10;<br>}<br><strong>子类</strong><br>public class Zi extends Fu {<br>   public int num = 20;</p>
<p>   public void methodZi(){<br>       int num = 30;<br>       System.out.println(num);      //30, 局部变量<br>       System.out.println(this.num); //20, 本类的成员变量<br>       System.out.println(super.num);//10, 父类的成员变量<br>   }<br>}<br>通过结果看看子类方法 methodZi() 能不能正确区分三个num</p>
<p>public class Demo03Main {<br>   public static void main(String[] args) {<br>       Zi zi = new Zi();<br>       zi.methodZi();  //30, 20, 10<br>   }<br>}<br><strong>总结</strong>：要想正确地打印想要的num，可以这样打<br>局部变量，上面的那个num = 30，就可以直接写<br>本类的成员变量，上面的num = 20, 用this.成员变量名<br>父类的成员变量，上面的num = 10, 用super.成员变量名</p>
<h4 id="继承中成员方法重名的问题"><a href="#继承中成员方法重名的问题" class="headerlink" title="继承中成员方法重名的问题"></a>继承中成员方法重名的问题</h4><p>假如子类和父类都有一个方法叫 method() , 那怎么知道用的是哪一个呢？<br>父类<br>public class Fu {<br>   public void method(){<br>       System.out.println(“父类重名方法执行”);<br>   }<br>}<br>子类<br>public class Zi extends Fu {<br>   public void method(){<br>       System.out.println(“子类重名方法执行”);<br>   }<br>}<br>在main中调用 method() 方法<br>public class Demo04Main {<br>   public static void main(String[] args) {<br>       Fu fu1 = new Fu();<br>       Fu fu2 = new Zi(); //通过子类来构造fu2<br>       Zi zi = new Zi();<br>       fu1.method(); //父类重名方法执行, 用的是父类方法<br>       fu2.method(); //子类重名方法执行，用的是子类方法<br>       zi.method();  //子类重名方法执行， 用的是子类方法<br>   }<br>}<br><strong>结论 :</strong><br>创建的对象是谁，用谁的类来构造对象的，就优先用谁，如果没有就向上找。比如Fu fu2 = new Zi();，fu2是用子类来构造的，那fu2.method()就是用的子类的方法<br>注意！无论是成员变量还是成员方法，如果没有都是向上找父类，绝对不会向下找子类的。</p>
<h4 id="继承方法中的覆盖重写"><a href="#继承方法中的覆盖重写" class="headerlink" title="继承方法中的覆盖重写"></a>继承方法中的覆盖重写</h4><p>由 继承中成员方法重名的问题，我们可以引出重写（Override）的概念<br>重写：在继承关系中，方法的名称一样，参数列表也一样<br>重写 (Override) 和 重载 (Overload) 的区别<br>重写：方法的名称一样，参数列表【也一样】。也叫覆盖、覆写<br>重载：方法的名称一样，参数列表【不一样】。</p>
<h3 id="覆盖重写的注意事项"><a href="#覆盖重写的注意事项" class="headerlink" title="覆盖重写的注意事项"></a>覆盖重写的注意事项</h3><p>必须保证父子类之间方法的名称相同，参数列表也相同，否则无法进行覆盖重写<br><strong>注解：</strong><br><strong>@Override</strong>，这个注解写在方法的前面，用来检验是不是有效的覆盖重写，例如当方法名写错了，@Override底下就会出现红色的波浪线，提示你这不是有效的覆盖重写。</p>
<p>public class Zi extends Fu {<br>   @Override<br>   public void method(){<br>       System.out.println(“子类重名方法执行”);<br>   }<br>}<br>这个注解可写可不写，但是强烈推荐把它写上去。<br><strong>子类方法的返回值必须【小于等于】父类方法的返回值范围。java.lang.Object是所有类的公共最高父类（祖宗类），每个类都默认继承了它，例如String类就是Object的子类。下面代码会报错，是因为返回值的范围问题</strong><br><strong>父类</strong><br>public class Fu {<br>   public String method(){<br>       System.out.println(“父类重名方法执行”);<br>   }<br>}<br>子类<br>public class Zi extends Fu {<br>   @Override<br>   public Object method(){  //范围：Object &gt; String 报错<br>       System.out.println(“子类重名方法执行”);<br>   }<br>}<br>子类方法的权限必须【大于等于】父类方法的权限修饰符。权限的排名：public &gt; protected &gt; (default) &gt; private。备注：（default）不是关键字default，而是什么都不写，留空，例如：<br>public class Fu{<br>   int num; //num的访问权限是default<br>}<br><strong>下面的代码会因为重写方法的权限问题而报错：</strong><br>父类<br>public class Fu {<br>   public void method(){<br>       System.out.println(“父类重名方法执行”);<br>   }<br>}<br>子类<br>public class Zi extends Fu {<br>   @Override<br>   protected void method(){  //protected &lt; public 报错<br>       System.out.println(“子类重名方法执行”);<br>   }<br>}</p>
<hr>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><hr>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><hr>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><h4 id="super关键字的三种用法总结"><a href="#super关键字的三种用法总结" class="headerlink" title="super关键字的三种用法总结"></a>super关键字的三种用法总结</h4><ul>
<li>用法1</li>
</ul>
<p>在子类的成员方法中，访问父类的成员变量，比如：<br>父类<br>public class Fu {<br>public int num = 10;<br>}<br>子类<br>public class Zi extends Fu {<br>public int num = 20;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void methodZi()&#123;</span><br><span class="line">   &#x2F;&#x2F; System.out.println(num);  这样打印的一定是本类的num</span><br><span class="line">    System.out.println(super.num); &#x2F;&#x2F;打印的是父类的num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<ul>
<li>用法2</li>
</ul>
<p>在子类的成员方法中，访问父类的成员方法，比如：<br>父类<br>public class Fu {<br>public void methodFu(){<br>System.out.println(“父类的成员方法执行”);<br>}<br>}<br>子类<br>public class Zi extends Fu{<br>public void methodZi(){<br>super.methodFu(); //访问父类的methodFu()方法<br>System.out.println(“子类的成员方法执行”);<br>}<br>}<br>在main中执行子类的方法<br>public class Demo07Main {<br>public static void main(String[] args) {<br>Zi zi = new Zi();<br>zi.methodZi();<br>}<br>}<br>/*输出结果：<br>父类的成员方法执行<br>子类的成员方法执行<br>*/</p>
<ul>
<li>用法3</li>
</ul>
<p><strong>在子类的构造方法中，访问父类的构造方法</strong>。就在 . 继承中构造方法的访问特点 中，请自行查阅。</p>
<h4 id="this关键字的三种用法"><a href="#this关键字的三种用法" class="headerlink" title="this关键字的三种用法"></a>this关键字的三种用法</h4><p>概述</p>
<ol>
<li>在本类的成员方法中，访问本类的成员变量</li>
<li>在本类的成员方法中，访问本类的另一个成员方法</li>
<li>在本类的构造方法中，访问本类的另一个构造方法</li>
</ol>
<p>代码说明<br>public class Zi extends Fu {<br>private int num = 10;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Zi()&#123;</span><br><span class="line">    this(123);  &#x2F;&#x2F;9.1.3 在本类的无参构造中调用有参构造</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Zi(int num)&#123;</span><br><span class="line">    this.num &#x3D; num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodZi()&#123;</span><br><span class="line">    System.out.println(this.num); &#x2F;&#x2F;9.1.1 在本类的成员方法中，访问本类的成员变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodA()&#123;</span><br><span class="line">    System.out.println(&quot;A方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodB()&#123;</span><br><span class="line">    this.methodA();  &#x2F;&#x2F;9.1.2 在本类的成员方法中，访问本类的另一个成员方法</span><br><span class="line">    System.out.println(&quot;B方法&quot;);</span><br></pre></td></tr></table></figure>

<p>9.3 注意事项</p>
<ul>
<li>在构造方法中调用this，那这个this调用必须是该函数中的第一个语句，也是唯一的一个</li>
<li>super和this两种在构造调用中，不能同时使用。两个都要排在第一行</li>
</ul>
<h3 id="关键字的具体用法（语法语句规则）"><a href="#关键字的具体用法（语法语句规则）" class="headerlink" title="关键字的具体用法（语法语句规则）"></a>关键字的具体用法（语法语句规则）</h3>]]></content>
      <categories>
        <category>java语法</category>
      </categories>
      <tags>
        <tag>java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础概念</title>
    <url>/2020/02/28/JAVA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>Java作为一种面向对象语言。支持以下基本概念：</p>
<ul>
<li>多态</li>
<li>继承</li>
<li>封装</li>
<li>抽象</li>
<li>类</li>
<li>对象</li>
<li>实例</li>
<li>方法</li>
<li>重载</li>
</ul>
<h2 id="Java对象和类"><a href="#Java对象和类" class="headerlink" title="Java对象和类"></a>Java对象和类</h2><p>类可以看成创建Java对象的模板</p>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>局部变量：在方法法、构造方法或者语句块中定义的变量，此类变量的声明和初始化都是在方法中，方法结束后，变量会自动销毁。<br>成员变量（非静态变量）：定义在类中，方法体之外的变量。这种变量在创建对象的时候被实例化，成员变量可以被类中方法、构造方法和特点类的语句块访问。<br>类变量（静态变量）：类变量也声明在类中，方法体之外，但必须声明为static类型。<br>实例变量也叫对象变量（成员变量），即没加static 的变量；成员变量和类变量两者区别在于：类变量和实例变量的区别在于：类变量是所有对象共有，其中一个对象将它值改变，其他对象得到的就是改变后的结果；而实例变量则属对象私有，某一个对象将其值改变，不影响其他对象；</p>
 <a id="more"></a>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法的作用就是给对象的数据进行初始化的。构造方法没有返回值！！<br>构造方法是类的一个特殊的成员，在类实例化时会自动调用。每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。<br>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。<br>注意：1.方法名与类名相同。<br>           2.没有返回值类型。<br>           3.没有具体的返回值。<br>构造方法分为：无参构造方法和有参构造方法。<br>构造方法注意事项：<br>1.java中的每一个类都至少有一个构造方法，如果我们没有创建，系统会为我们创建一个默认的无参构造方法。(不显示代码)<br>2.但是如果我们定义了构造方法，系统就不会再为我们提供默认的无参构造方法了。这个时候想使用无参构造方法必须自己定义。因为实例化对象时，不一定会输入参数，那么没有无参的构造方法，又不输入参数，就会出错。<br>3.构造方法需要用public来修饰，若使用private，在其他类中无法将其实例化。<br>4.构造方法是可以重载的。<br><strong>重载</strong>： 重载（Overload）是让类以统一的方式处理不同类型数据的一种手段，实质表现就是多个具有不同的参数个数或者类型的同名函数（返回值类型可随意，不能以返回类型作为重载函数的区分标准）同时存在于同一个类中，是一个类中多态性的一种表现（调用方法时通过传递不同参数个数和参数类型来决定具体使用哪个方法的多态性）。<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/539392/1576741684942-7670e4db-4691-4171-b562-df36aa020259.jpeg#align=left&display=inline&height=244&originHeight=303&originWidth=600&size=0&status=done&style=none&width=483" alt></p>
<p>public static void main(String[] args)是入口方法</p>
<h3 id><a href="#" class="headerlink" title></a></h3><hr>
<p>**</p>
<h3 id="基本类型与包装类型"><a href="#基本类型与包装类型" class="headerlink" title="基本类型与包装类型"></a>基本类型与包装类型</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1576774088275-7ebc84f1-8301-4702-86c0-8be28c7d03e9.png#align=left&display=inline&height=268&originHeight=268&originWidth=856&size=0&status=done&style=none&width=856" alt><br>Java中的基本数据类型没有方法和属性，而包装类就是为了让这些拥有方法和属性，实现对象化交互。<br>所谓包装类，就是能够直接将简单类型的变量表示为一个类，在执行变量类型的相互转换时，我们会大量使用这些包装类。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1576774002998-c994a5f0-0c4f-4616-b99d-f6a263623d45.png#align=left&display=inline&height=282&originHeight=302&originWidth=436&size=0&status=done&style=none&width=407" alt></p>
<h4 id="包装类用途"><a href="#包装类用途" class="headerlink" title="包装类用途"></a>包装类用途</h4><p>1.集合不允许存放基本数据类型，故常用包装类<br>2.包含了每种基本类型的相关属性，如最大值，最小值，所占位数等<br>3.作为基本数据类型对应的类类型，提供了一系列实用的对象操作，如类型转换，进制转换等</p>
<hr>
<h4 id="基本类型与包装类型的区别"><a href="#基本类型与包装类型的区别" class="headerlink" title="基本类型与包装类型的区别"></a>基本类型与包装类型的区别</h4><p>1、在Java中，一切皆对象，但八大基本类型却不是对象。<br>2、声明方式的不同，基本类型无需通过new关键字来创建，而封装类型需new关键字。<br>3、存储方式及位置的不同，基本类型是直接存储变量的值保存在堆栈中能高效的存取，封装类型需要通过引用指向实例，具体的实例保存在堆中。<br>4、<strong>初始值的不同，封装类型的初始值为null，</strong>基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；<br>5、使用方式的不同，比如与集合类合作使用时只能使用包装类型。<br>6、什么时候该用包装类，什么时候用基本类型，看基本的业务来定：这个字段允允许null值，就需要使用包装类型，如果不允许null值，，使用基本类型就可以了，用到比如泛型和反射调用函数，就需要用包装类！<br><strong>所以最基本的一点区别是</strong>：Ingeter是int的包装类，int的初值为0，Ingeter的初值为null。</p>
<h4 id="基本数据和包装类之间的转换"><a href="#基本数据和包装类之间的转换" class="headerlink" title="基本数据和包装类之间的转换"></a>基本数据和包装类之间的转换</h4><p>装箱：基本数据类型转换为包装类；<br> 拆箱：包装类转换为基本数据类型。　</p>
<h4 id="基本数据类型和包装类的转换"><a href="#基本数据类型和包装类的转换" class="headerlink" title="基本数据类型和包装类的转换"></a>基本数据类型和包装类的转换</h4><p>通过包装类Integer.toString()将整型转换为字符串；<br>通过Integer.parseInt()将字符串转换为int类型；<br>通过valueOf()方法把字符串转换为包装类然后通过自动拆箱。<br>注：<br>　　Java中除了float和double的其他基本数据类型，都有常量池（注：Python中int【-5~256，257 这个整数对象是区分作用域的，它只有在相同的作用域, 内存地址才会相同】,str,byte也有）</p>
<h4 id="JVM几种常量池"><a href="#JVM几种常量池" class="headerlink" title="JVM几种常量池"></a>JVM几种常量池</h4><p>主要分为： Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池。</p>
<h3 id="class对象的声明与实例化"><a href="#class对象的声明与实例化" class="headerlink" title="class对象的声明与实例化"></a>class对象的声明与实例化</h3><p>在定义类时，只是通知编译器需要准备多大的内存空间，并没有为它分配内存空间。只有用类创建了对象后，才会真正占用内存空间。所以与基本数据类型不同的是：对象在声明时不分配内存空间，仅声明该对象属于什么类，需要对其进行实例化才会进行空间的分配；而基本数据类型在定义之后，无论是否进行赋值，都会分配一定的空间。<br>** 1． 声明对象**<br>对象的声明和基本类型的数据声明在形式上是一样的：<br>类名 对象名；<br>对象名也是用户标识符，和基本类型的变量遵循同样的命名规则和使用规则。<br>声明一个变量，并不会分配一个完整的对象所需要的内存空间，只是将对象名所代表的变量看成是一个引用变量，并为它分配所需内存空间，它所占用的空间远远小于一个类的对象所需要的空间。<br>如此处理，使得Java中声明一个对象的消耗很小，但也有一个副作用，就是对象不能马上使用，还需要对它进行实例化。<br>** 2． 实例化对象（创建一个对象）**<br>用new关键字创建一个新对象，即进行实例化。格式如下：<br>new 构造方法([参数列表])<br>实例化的过程就是为对象分配内存空间的过程，此时，对象才成为类的实例。new所执行的具体操作是调用相应类中的构造方法（包括祖先类的构造方法），来完成内存分配以及变量的初始化工作，然后将分配的内存地址返回给所定义的变量。<br>实质：实例化了就有自己内存空间。而没有实例化就和引用的对象内存空间地址相同，指向同一个空间。<br>所以说实际应用中：用new来实例化一个对象的语句是：Student student = new Student();类名 对象名 = new 类名（）；</p>
<p>实例化对象（创建）的五种方式</p>
<p>  类实例化就是<a href="https://www.baidu.com/s?wd=%E6%96%B0%E5%BB%BA&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">新建</a>一个类的对象，就是new一个对象，类在没有实例化之前,就是new之前,它的属性,方法等等在内存中都是不存在的.只有new了以后,这个类的一些东西在内存中才会真的存在,也就是说只有new了之后,这个类才能用</p>
<ul>
<li>用new语句创建对象，这是最常见的创建对象的方法；类名 对象名 = new 类名（）；例：Student stu = new Student（）；</li>
<li>调用对象的clone（）方法；</li>
<li>运用反射手段；Class类的newInstance方法（Student.class.newInstance()）或者Constructor类的newInstance方法（java.lang.relect.Constructor类里的newInstance方法）。调用java.lang.Class或者java.lang。 reflect.Constructor类的newInstance（）实例方法。如：Object obj = Class.forName（“java.lang.Object”）。newInstance（）;</li>
<li>通过I / O流（包括反序列化），如运用反序列化手段，调用java.io.ObjectInputStream对象的readObject（）方法；</li>
<li>通过工厂方法返回对象，如：String str = String.valueOf（23）；</li>
</ul>
<h4 id="一个Java对象创建的真实过程"><a href="#一个Java对象创建的真实过程" class="headerlink" title="一个Java对象创建的真实过程"></a>一个Java对象创建的真实过程</h4><pre><code>所谓的对象其实就是通过java类所产生的实体。在Java中，一个对象在可以被使用之前必须要被正确地初始化，这一点是Java规范规定的。在实例化一个对象时，JVM首先会检查相关类型是否已经加载并初始化，如果没有，则JVM立即进行加载并调用类构造器完成类的初始化。在类初始化过程中或初始化完毕后，根据具体情况才会去对类进行实例化。本文试图对JVM执行类初始化和实例化的过程做一个详细深入地介绍，以便从Java虚拟机的角度清晰解剖一个Java对象的创建过程。</code></pre><p>所以说一个Java对象的创建过程往往包括** 类初始化** 和 <strong>类实例化</strong> 两个阶段。<br>  当一个对象被创建时，虚拟机就会为其分配内存来存放对象自己的实例变量及其从父类继承过来的实例变量(即使这些从超类继承过来的实例变量有可能被隐藏也会被分配空间)。在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值(零值)。在内存分配完成之后，Java虚拟机就会开始对新创建的对象按照编程者的意志进行初始化。在Java对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是 实例变量初始化、实例代码块初始化 以及 构造函数初始化。</p>
<ul>
<li>实例变量初始化</li>
<li>实例代码块初始化</li>
</ul>
<p>我们在定义（声明）实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。如果我们以这两种方式为实例变量进行初始化，那么它们将在构造函数执行之前完成这些初始化操作。实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后(Java要求构造函数的第一条语句必须是超类构造函数的调用语句)，构造函数本身的代码之前。</p>
<ul>
<li><p>构造函数初始化</p>
<p>实例变量初始化与实例代码块初始化总是发生在构造函数初始化之前，那么我们下面着重看看构造函数初始化过程。众所周知，每一个Java中的对象都至少会有一个构造函数，如果我们没有显式定义构造函数，那么它将会有一个默认无参的构造函数。在编译生成的字节码中，这些构造函数会被命名成<init>()方法，参数列表与Java语言书写的构造函数的参数列表相同。<br>Java要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。事实上，这一点是在构造函数中保证的：Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用</init></p>
</li>
</ul>
<p>超类构造函数：<br>this 和super在构造函数中只能有一个，且都必须是构造函数当中的第一行。<br>super关键字，子类可以通过它调用父类的构造函数。<br>1、当父类的构造函数是无参构造函数时，在子类的构造函数中，就算不写super()去调用父类的构造函数，编译器不会报错，因为编译器会默认的去调用父类的无参构造函数。<br>2、当父类的构造函数是有参构造函数时，此时如果子类的构造函数中不写super()进行调用父类的构造函数，编译器会报错，此时不能省去super（）<br>  如果父类有无参构造方法，那么在写子类的构造方法时可以不用super调用，其实就是调用父类的无参构造方法，总的来说就是子类的构造方法创建时要调用父类的构造方法。<br> 子类继承了父类，若父类的构造方法没有重载那么，子类的构造方法也不需要通过super调用父类构造方法。一个类中如果构造方法重写了并且带了参数，那么这个类的原来系统默认的无参构造方法便消失。由此，若一个父类中只有一个带参数的构造方法，那么在写其子类的构造方法时必须先通过super调用父类的构造方法才能完成子类的构造方法而且super只能写在子类构造方法体内的第一行。</p>
<p><a href="https://blog.csdn.net/justloveyou_/article/details/72466416" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/72466416</a></p>
<p>在java中用{}括起来的称为代码块，代码块可分为以下四种：<br>  1.普通代码块：</p>
<pre><code>类中方法的方法体</code></pre><p>  2.构造代码块：<br>     构造块会在创建对象时被调用，每次创建时都会被调用，优先于类构造函数执行。<br>  3.静态代码块：<br>     用static{}包裹起来的代码片段，只会执行一次。静态代码块优先于构造块执行。<br>  4.同步代码块：<br>       使用synchronized（）{}包裹起来的代码块，在多线程环境下，对共享数据的读写操作是需要互斥进行的，否则会导致数据的不一致性。同步代码块需要写在方法中。</p>
<ul>
<li><p>静态代码块:在java中使用static关键字声明的代码块。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行。如果类中包含多个静态代码块，那么将按照”先定义的代码先执行，后定义的代码后执行”。</p>
<p>  注意：1 .静态代码块不能存在于任何方法体内。</p>
<pre><code>2 .静态代码块不能直接访问实例变量和实例方法，需要通过类的实例对象来访问。</code></pre></li>
<li><p>构造代码块：<strong>直接在类中定义且没有加static关键字的代码块</strong>称为{}构造代码块。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数。如果存在多个构造代码块，执行顺序由他们在代码中出现的次序决定，先出现先执行。</p>
</li>
</ul>
<p>二.静态代码块和构造代码块的异同点<br>  相同点：都是JVM加载类后且在构造函数执行之前执行，在类中可定义多个，一般在代码块中对一些static变量进行赋值。<br>  不同点：静态代码块在非静态代码块之前执行。静态代码块只在第一次new时执行一次，之后不在执行。而非静态代码块每new一次就执行一次。</p>
<h4 id="静态代码块、构造代码块、构造函数、普通代码块的执行顺序"><a href="#静态代码块、构造代码块、构造函数、普通代码块的执行顺序" class="headerlink" title="静态代码块、构造代码块、构造函数、普通代码块的执行顺序"></a>静态代码块、构造代码块、构造函数、普通代码块的执行顺序</h4><p>构造函数的功能主要用于在类的对象创建时定义初始化的状态。<br>静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。</p>
<p>构造方法定义格式：</p>
<blockquote>
<p>修饰符   方法名（）<br>{<br>}</p>
</blockquote>
<p>注意：1.方法名与类名相同。<br>           2.没有返回值类型。<br>           3.没有具体的返回值</p>
<h4 id="构造方法重载"><a href="#构造方法重载" class="headerlink" title="构造方法重载"></a>构造<a href="https://www.baidu.com/s?wd=%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YvuWbYuW7huW6snWwBn1fz0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3En1csrHn4Pjfs" target="_blank" rel="noopener">方法重载</a></h4><p>可以在一个构造方法里调用其他重载的构造方法，不是用构造方法名，而是用this（参数列表）的形式，根据其中的参数列表，选择相应的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> age;      <span class="comment">// 年龄</span></span><br><span class="line">      <span class="keyword">int</span> hight;    <span class="comment">// 身体高度</span></span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          print();</span><br><span class="line">          <span class="keyword">this</span>.age=<span class="number">20</span>;   <span class="comment">//这里初始化 age 的值</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>();      <span class="comment">// 调用自己的第一个构造函数，下面的两个语句不执行的</span></span><br><span class="line">         <span class="keyword">this</span>.age = age;</span><br><span class="line">         print();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>(age);   <span class="comment">// 调用自己第二个构造函数  ，下面的两个语句不执行的</span></span><br><span class="line">         <span class="keyword">this</span>.hight = hight;</span><br><span class="line">         print();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">         System.out.println(<span class="string">"I'am a "</span> + age + <span class="string">"岁 "</span> + hight + <span class="string">"尺高 tiger!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> Father(<span class="number">22</span>,<span class="number">7</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>这种this语句用于构造函数间的调用出现的场景：构造函数有很多，但对外提供的却不多，这时用this语句，使少量的构造函数暴露。</strong></li>
<li><strong>this调用只能放在构造函数中的第一行（因为初始化动作总是要先执行，如果初始化里还有更细的初始化，则从最小粒度的初始化开始，先执行）。</strong></li>
</ul>
<p><strong>问题：一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</strong><br>　　<strong>答案：可以有多个类，但只能有一个**</strong>public的类，并且public的类名必须与文件名相一致。一个文件中可以只有非public类，如果只有一个非public类，此类可以跟文件名不同。**</p>
<p><strong>为什么一个java源文件中只能有一个public类？</strong><br>**　　在java编程思想（第四版）一书中有这样3段话（6.4 类的访问权限）：**<br>**　　1.每个编译单元（文件）都只能有一个public类，这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出错误信息。**<br>**　　2.public类的名称必须完全与含有该编译单元的文件名相同，包含大小写。如果不匹配，同样将得到编译错误。**<br>**　　3.虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。**<br><strong>**当java源文件不存在public类时，会出现什么情况？</strong><br><strong>如下图所示：</strong><br>**<br><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1576771945852-8ce8d604-72c9-4617-8627-38d797af0cf4.png#align=left&display=inline&height=277&originHeight=395&originWidth=864&size=0&status=done&style=none&width=606" alt></p>
<p>**　**</p>
<p><strong>此时程序编译通过，在相应路径下产生了三个.class文件。直接点击运行，程序是不能运行的，我们需要鼠标右键点击程序—–&gt;Run As—–&gt;Java Aplication—–&gt;选数据来源</strong><br>**<img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1576772032975-07900201-5e16-48f8-9d82-454cfe9c31ce.png#align=left&display=inline&height=226&originHeight=415&originWidth=1054&size=0&status=done&style=none&width=573" alt></p>
<p><strong>总结：</strong><br>**　　<strong>一个编译单元（java文件）</strong>可以存在多个类，在编译时产生多个不同的.class文件，.class文件便是程序运行的数据来源。java将public类作为每个编译单元的数据接口，只能有一个，不然不能处理存在多个类的java文件。当一个编译单元（java文件）有多个非public类时，运行时需要对数据来源进行选择。**</p>
]]></content>
      <categories>
        <category>java语法</category>
      </categories>
      <tags>
        <tag>java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC核心技术</title>
    <url>/2020/02/28/JDBC/</url>
    <content><![CDATA[<h1 id="JDBC核心技术"><a href="#JDBC核心技术" class="headerlink" title="JDBC核心技术"></a>JDBC核心技术</h1><p>Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。我们通常说的JDBC是面向关系型数据库的。</p>
<a id="more"></a>

<h2 id="第1章：JDBC概述"><a href="#第1章：JDBC概述" class="headerlink" title="第1章：JDBC概述"></a>第1章：JDBC概述</h2><h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul>
<li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p>
</li>
<li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p>
<p><img src="/2020/02/28/JDBC/1566741430592.png" alt="1566741430592"> </p>
</li>
</ul>
<h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul>
<li><p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li><p><strong>JDBC</strong>直接访问数据库</p>
</li>
<li><p>JDO (Java Data Object )技术</p>
</li>
<li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p>
</li>
</ul>
</li>
<li><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p>
</li>
</ul>
<h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul>
<li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li>
<li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
<li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="/2020/02/28/JDBC/1555575760234.png" alt="1555575760234"></p>
<hr>
<ul>
<li>有了JDBC，Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="/2020/02/28/JDBC/1555575981203.png" alt="1555575981203"></p>
<hr>
<ul>
<li>总结如下：</li>
</ul>
<p><img src="/2020/02/28/JDBC/1566741692804.png" alt="1566741692804"></p>
<h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul>
<li>JDBC接口（API）包括两个层次：<ul>
<li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li>
<li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p>
<p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p>
</blockquote>
<h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><p><img src="/2020/02/28/JDBC/1565969323908.png" alt="1565969323908"></p>
<blockquote>
<p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p>
</blockquote>
<h2 id="第2章：获取数据库连接"><a href="#第2章：获取数据库连接" class="headerlink" title="第2章：获取数据库连接"></a>第2章：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类"><a href="#2-1-要素一：Driver接口实现类" class="headerlink" title="2.1 要素一：Driver接口实现类"></a>2.1 要素一：Driver接口实现类</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul>
<li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p>
</li>
<li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p>
<ul>
<li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li>
<li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li>
</ul>
</li>
</ul>
<p><img src="/2020/02/28/JDBC/1555576157618.png" alt="1555576157618"></p>
<p><img src="/2020/02/28/JDBC/1555576170074.png" alt="1555576170074"></p>
<ul>
<li><p>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</p>
<p><img src="/2020/02/28/JDBC/1566134718955.png" alt="1566134718955"></p>
</li>
</ul>
<p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p>
<p> <img src="/2020/02/28/JDBC/1566134781682.png" alt="1566134781682"></p>
<p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p>
<p> <img src="/2020/02/28/JDBC/1566135290460.png" alt="1566135290460"></p>
<h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul>
<li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p>
<ul>
<li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li>
</ul>
</li>
<li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p>
<ul>
<li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p>
</li>
<li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p>
<p><img src="/2020/02/28/JDBC/1566136831283.png" alt="1566136831283"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h3><ul>
<li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p>
</li>
<li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p>
<ul>
<li><strong>jdbc:子协议:子名称</strong></li>
<li><strong>协议</strong>：JDBC URL中的协议总是jdbc </li>
<li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li>
<li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li>
</ul>
</li>
<li><p>举例：</p>
<p><img src="/2020/02/28/JDBC/1555576477107.png" alt="1555576477107"></p>
</li>
<li><p><strong>几种常用数据库的 JDBC URL</strong></p>
<ul>
<li><p>MySQL的连接URL编写方式：</p>
<ul>
<li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li>
<li>jdbc:mysql://localhost:3306/atguigu</li>
<li>jdbc:mysql://localhost:3306/atguigu<strong>?useUnicode=true&amp;characterEncoding=utf8</strong>（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li>
<li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li>
</ul>
</li>
<li><p>Oracle 9i的连接URL编写方式：</p>
<ul>
<li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li>
<li>jdbc:oracle:thin:@localhost:1521:atguigu</li>
</ul>
</li>
<li><p>SQLServer的连接URL编写方式：</p>
<ul>
<li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p>
</li>
<li><p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul>
<li>user,password可以用“属性名=属性值”方式告诉数据库</li>
<li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li>
</ul>
<h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">           Driver driver = <span class="keyword">null</span>;</span><br><span class="line">           driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">"user"</span>, <span class="string">"root"</span>);</span><br><span class="line">           info.setProperty(<span class="string">"password"</span>, <span class="string">"abc123"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上述代码中显式出现了第三方数据库的API</p>
</blockquote>
<h4 id="2-4-2-连接方式二"><a href="#2-4-2-连接方式二" class="headerlink" title="2.4.2 连接方式二"></a>2.4.2 连接方式二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.实例化Driver</span></span><br><span class="line">           String className = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">           Class clazz = Class.forName(className);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">"user"</span>, <span class="string">"root"</span>);</span><br><span class="line">           info.setProperty(<span class="string">"password"</span>, <span class="string">"abc123"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p>
</blockquote>
<h4 id="2-4-3-连接方式三"><a href="#2-4-3-连接方式三" class="headerlink" title="2.4.3 连接方式三"></a>2.4.3 连接方式三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">           String user = <span class="string">"root"</span>;</span><br><span class="line">           String password = <span class="string">"abc123"</span>;</span><br><span class="line">           String driverName = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           Class clazz = Class.forName(driverName);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           DriverManager.registerDriver(driver);</span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p>
</blockquote>
<h4 id="2-4-4-连接方式四"><a href="#2-4-4-连接方式四" class="headerlink" title="2.4.4 连接方式四"></a>2.4.4 连接方式四</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">           String user = <span class="string">"root"</span>;</span><br><span class="line">           String password = <span class="string">"abc123"</span>;</span><br><span class="line">           String driverName = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">           Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">           static &#123;</span></span><br><span class="line"><span class="comment">               try &#123;</span></span><br><span class="line"><span class="comment">                   DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">               &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                   throw new RuntimeException("Can't register driver!");</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p>
</blockquote>
<h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   	<span class="comment">//1.加载配置文件</span></span><br><span class="line">       InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream("jdbc.properties");</span><br><span class="line">       Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">       pros.load(is);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.读取配置信息</span></span><br><span class="line">       String user = pros.getProperty(<span class="string">"user"</span>);</span><br><span class="line">       String password = pros.getProperty(<span class="string">"password"</span>);</span><br><span class="line">       String url = pros.getProperty(<span class="string">"url"</span>);</span><br><span class="line">       String driverClass = pros.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.加载驱动</span></span><br><span class="line">       Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.获取连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">       System.out.println(conn);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p>
<p><strong>使用配置文件的好处：</strong></p>
<p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p>
</blockquote>
<h2 id="第3章：使用PreparedStatement实现CRUD操作"><a href="#第3章：使用PreparedStatement实现CRUD操作" class="headerlink" title="第3章：使用PreparedStatement实现CRUD操作"></a>第3章：使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul>
<li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p>
</li>
<li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p>
<ul>
<li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li>
<li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li>
<li>CallableStatement：用于执行 SQL 存储过程</li>
</ul>
<p><img src="/2020/02/28/JDBC/1566573842140.png" alt="1566573842140"></p>
</li>
</ul>
<h3 id="3-2-使用Statement操作数据表的弊端"><a href="#3-2-使用Statement操作数据表的弊端" class="headerlink" title="3.2 使用Statement操作数据表的弊端"></a>3.2 使用Statement操作数据表的弊端</h3><ul>
<li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p>
</li>
<li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">int excuteUpdate(String sql)：执行更新操作<span class="keyword">INSERT</span>、<span class="keyword">UPDATE</span>、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(<span class="keyword">String</span> <span class="keyword">sql</span>)：执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但是使用Statement操作数据表存在弊端：</p>
<ul>
<li><strong>问题一：存在拼串操作，繁琐</strong></li>
<li><strong>问题二：存在SQL注入问题</strong></li>
</ul>
</li>
<li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p>
</li>
<li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p>
</li>
<li><p>代码演示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">		System.out.print(<span class="string">"用户名："</span>);</span><br><span class="line">		String userName = scan.nextLine();</span><br><span class="line">		System.out.print(<span class="string">"密   码："</span>);</span><br><span class="line">		String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// SELECT user,password FROM user_table WHERE USER = '1' or ' AND PASSWORD = '='1' or '1' = '1';</span></span><br><span class="line">		String sql = <span class="string">"SELECT user,password FROM user_table WHERE USER = '"</span> + userName + <span class="string">"' AND PASSWORD = '"</span> + password</span><br><span class="line">				+ <span class="string">"'"</span>;</span><br><span class="line">		User user = get(sql, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"登陆成功!"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"用户名或密码错误！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		Statement st = <span class="keyword">null</span>;</span><br><span class="line">		ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1.加载配置文件</span></span><br><span class="line">			InputStream is = StatementTest.class.getClassLoader().getResourceAsStream("jdbc.properties");</span><br><span class="line">			Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">			pros.load(is);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 2.读取配置信息</span></span><br><span class="line">			String user = pros.getProperty(<span class="string">"user"</span>);</span><br><span class="line">			String password = pros.getProperty(<span class="string">"password"</span>);</span><br><span class="line">			String url = pros.getProperty(<span class="string">"url"</span>);</span><br><span class="line">			String driverClass = pros.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3.加载驱动</span></span><br><span class="line">			Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 4.获取连接</span></span><br><span class="line">			conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">			st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">			rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取结果集的元数据</span></span><br><span class="line">			ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取结果集的列数</span></span><br><span class="line">			<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">				t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">					<span class="comment">// //1. 获取列的名称</span></span><br><span class="line">					<span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// 1. 获取列的别名</span></span><br><span class="line">					String columnName = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">					Object columnVal = rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line">					Field field = clazz.getDeclaredField(columnName);</span><br><span class="line">					field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">					field.set(t, columnVal);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 关闭资源</span></span><br><span class="line">			<span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					rs.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					st.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					conn.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上：</p>
<p><img src="/2020/02/28/JDBC/1566569819744.png" alt="1566569819744"></p>
<h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul>
<li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p>
</li>
<li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p>
</li>
<li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p>
</li>
</ul>
<h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul>
<li><p>代码的可读性和可维护性。</p>
</li>
<li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p>
<ul>
<li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li>
<li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li>
<li>(语法检查，语义检查，翻译成二进制命令，缓存)</li>
</ul>
</li>
<li><p>PreparedStatement 可以防止 SQL 注入 </p>
</li>
</ul>
<h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table>
<thead>
<tr>
<th>Java类型</th>
<th>SQL类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>String</td>
<td>CHAR,VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>byte   array</td>
<td>BINARY  ,    VAR BINARY</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
</tbody></table>
<h4 id="3-3-4-使用PreparedStatement实现增、删、改操作"><a href="#3-3-4-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.4 使用PreparedStatement实现增、删、改操作"></a>3.3.4 使用PreparedStatement实现增、删、改操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql,Object ... args)</span></span>&#123;</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//1.获取数据库的连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">//3.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4.执行sql语句</span></span><br><span class="line">		ps.execute();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//5.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(conn, ps);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-5-使用PreparedStatement实现查询操作"><a href="#3-3-5-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.5 使用PreparedStatement实现查询操作"></a>3.3.5 使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">		rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line">		ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line">		<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">		<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">			T t = clazz.newInstance();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 获取列值</span></span><br><span class="line">				Object columnVal = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line">				String columnLabel = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line">				Field field = clazz.getDeclaredField(columnLabel);</span><br><span class="line">				field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">				field.set(t, columnVal);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 7.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p>
</blockquote>
<h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul>
<li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p>
</li>
<li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p>
</li>
<li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p>
</li>
<li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p>
</li>
<li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p>
<ul>
<li>例如: getInt(1), getString(“name”)</li>
<li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li>
</ul>
</li>
<li><p>ResultSet 接口的常用方法：</p>
<ul>
<li><p>boolean next()</p>
</li>
<li><p>getString()</p>
</li>
<li><p>…</p>
</li>
</ul>
<p><img src="/2020/02/28/JDBC/1555580152530.png" alt="1555580152530"></p>
</li>
</ul>
<h4 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h4><ul>
<li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p>
</li>
<li><p>ResultSetMetaData meta = rs.getMetaData();</p>
<ul>
<li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p>
</li>
<li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p>
</li>
<li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p>
</li>
<li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p>
</li>
<li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p>
</li>
<li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p>
</li>
<li><p>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/02/28/JDBC/1555579494691.png" alt="1555579494691"></p>
<p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p>
<p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p>
<p><strong>问题2：关于ResultSetMetaData</strong></p>
<ol>
<li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li>
<li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li>
<li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li>
</ol>
<p><img src="/2020/02/28/JDBC/1555579816884.png" alt="1555579816884"></p>
<h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul>
<li>释放ResultSet, Statement,Connection。</li>
<li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li>
<li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li>
</ul>
<h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul>
<li><p>两种思想</p>
<ul>
<li><p>面向接口编程的思想</p>
</li>
<li><p>ORM思想(object relational mapping)</p>
<ul>
<li>一个数据表对应一个java类</li>
<li>表中的一条记录对应java类的一个对象</li>
<li>表中的一个字段对应java类的一个属性</li>
</ul>
</li>
</ul>
<blockquote>
<p>sql是需要结合列名和表的属性名来写。注意起别名。</p>
</blockquote>
</li>
<li><p>两种技术</p>
<ul>
<li>JDBC结果集的元数据：ResultSetMetaData<ul>
<li>获取列数：getColumnCount()</li>
<li>获取列的别名：getColumnLabel()</li>
</ul>
</li>
<li>通过反射，创建指定类的对象，获取指定的属性并赋值</li>
</ul>
</li>
</ul>
<hr>
<h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p>
<p><img src="/2020/02/28/JDBC/1555580275036.png" alt="1555580275036"></p>
<p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p>
<p><img src="/2020/02/28/JDBC/1555580735377.png" alt="1555580735377"></p>
<p>向数据表中添加如下数据：</p>
<p><img src="/2020/02/28/JDBC/1555580763636.png" alt="1555580763636"></p>
<p><strong>代码实现1：插入一个新的student 信息</strong></p>
<p>请输入考生的详细信息</p>
<p>Type:<br>IDCard:<br>ExamCard:<br>StudentName:<br>Location:<br>Grade:</p>
<p>信息录入成功!</p>
<p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p>
<p><img src="/2020/02/28/JDBC/1555580937490.png" alt="1555580937490"></p>
<p><strong>代码实现3：完成学生信息的删除功能</strong></p>
<p><img src="/2020/02/28/JDBC/1555580965019.png" alt="1555580965019"></p>
<hr>
<h2 id="第4章-操作BLOB类型字段"><a href="#第4章-操作BLOB类型字段" class="headerlink" title="第4章 操作BLOB类型字段"></a>第4章 操作BLOB类型字段</h2><h3 id="4-1-MySQL-BLOB类型"><a href="#4-1-MySQL-BLOB类型" class="headerlink" title="4.1 MySQL BLOB类型"></a>4.1 MySQL BLOB类型</h3><ul>
<li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p>
</li>
<li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p>
</li>
<li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p>
</li>
</ul>
<p><img src="/2020/02/28/JDBC/1555581069798.png" alt="1555581069798"></p>
<ul>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li>
<li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li>
</ul>
<h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">String sql = <span class="string">"insert into customers(name,email,birth,photo)values(?,?,?,?)"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">"徐海强"</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">"xhq@126.com"</span>);</span><br><span class="line">ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(<span class="keyword">new</span> java.util.Date().getTime()));</span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"xhq.png"</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>, fis);</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">ps.execute();</span><br><span class="line">		</span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>



<h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">String sql = <span class="string">"update customers set photo = ? where id = ?"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"coffee.png"</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>, fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>



<h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"SELECT id, name, email, birth, photo FROM customer WHERE id = ?"</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">	Integer id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">	String email = rs.getString(<span class="number">3</span>);</span><br><span class="line">    Date birth = rs.getDate(<span class="number">4</span>);</span><br><span class="line">	Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">    System.out.println(cust); </span><br><span class="line">    <span class="comment">//读取Blob类型的字段</span></span><br><span class="line">	Blob photo = rs.getBlob(<span class="number">5</span>);</span><br><span class="line">	InputStream is = photo.getBinaryStream();</span><br><span class="line">	OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"c.jpg"</span>);</span><br><span class="line">	<span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">		os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">	&#125;</span><br><span class="line">    JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">		is.close();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(os !=  <span class="keyword">null</span>)&#123;</span><br><span class="line">		os.close();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第5章-批量插入"><a href="#第5章-批量插入" class="headerlink" title="第5章 批量插入"></a>第5章 批量插入</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p>
<p>JDBC的批量处理语句包括下面三个方法：</p>
<ul>
<li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li>
<li><strong>executeBatch()：执行批量处理语句；</strong></li>
<li><strong>clearBatch():清空缓存的数据</strong></li>
</ul>
<p>通常我们会遇到两种批量执行SQL语句的情况：</p>
<ul>
<li>多条SQL语句的批量处理；</li>
<li>一个SQL语句的批量传参；</li>
</ul>
<h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p>
<ul>
<li>数据库中提供一个goods表。创建如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	String sql = <span class="string">"insert into goods(name) values('name_' + "</span>+ i +<span class="string">")"</span>;</span><br><span class="line">	st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">String sql = <span class="string">"insert into goods(name)values(?)"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	ps.setString(<span class="number">1</span>, <span class="string">"name_"</span> + i);</span><br><span class="line">	ps.executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"花费的时间为："</span> + (end - start));<span class="comment">//82340</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 修改1： 使用 addBatch() / executeBatch() / clearBatch()</span></span><br><span class="line"><span class="comment"> * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。</span></span><br><span class="line"><span class="comment"> * 		 ?rewriteBatchedStatements=true 写在配置文件的url后面</span></span><br><span class="line"><span class="comment"> * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">	Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">"insert into goods(name)values(?)"</span>;</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">"name_"</span> + i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">//3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">"花费的时间为："</span> + (end - start));<span class="comment">//20000条：625                                                                         //1000000条:14733  </span></span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 层次四：在层次三的基础上操作</span></span><br><span class="line"><span class="comment">* 使用Connection 的 setAutoCommit(false)  /  commit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">	Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//1.设置为不自动提交数据</span></span><br><span class="line">	conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">"insert into goods(name)values(?)"</span>;</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">"name_"</span> + i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">//3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//2.提交数据</span></span><br><span class="line">	conn.commit();</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">"花费的时间为："</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第6章：-数据库事务"><a href="#第6章：-数据库事务" class="headerlink" title="第6章： 数据库事务"></a>第6章： 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul>
<li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p>
</li>
<li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都<strong>被提交(commit)</strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务<strong>回滚(rollback)</strong>到最初状态。</p>
</li>
<li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p>
</li>
</ul>
<h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul>
<li><p>数据一旦提交，就不可回滚。</p>
</li>
<li><p>数据什么时候意味着提交？</p>
<ul>
<li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li>
</ul>
</li>
<li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p>
<ul>
<li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li>
<li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li>
</ul>
<blockquote>
<p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p>
</blockquote>
</li>
</ul>
<p>【案例：用户AA向用户BB转账100】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		<span class="comment">// 2.开启事务</span></span><br><span class="line">		conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 3.进行数据库操作</span></span><br><span class="line">		String sql1 = <span class="string">"update user_table set balance = balance - 100 where user = ?"</span>;</span><br><span class="line">		update(conn, sql1, <span class="string">"AA"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟网络异常</span></span><br><span class="line">		<span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line">		String sql2 = <span class="string">"update user_table set balance = balance + 100 where user = ?"</span>;</span><br><span class="line">		update(conn, sql2, <span class="string">"BB"</span>);</span><br><span class="line">		<span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">		conn.commit();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">			conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//7.关闭连接</span></span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，对数据库操作的方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> </span>&#123;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">// 2.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3.执行sql语句</span></span><br><span class="line">		ps.execute();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 4.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(<span class="keyword">null</span>, ps);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a>6.3 事务的ACID属性</h3><ol>
<li><p><strong>原子性（Atomicity）</strong><br> 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p>
</li>
<li><p><strong>一致性（Consistency）</strong><br> 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong><br> 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性（Durability）</strong><br> 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</li>
</ol>
<h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><ul>
<li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
</li>
<li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>
</li>
<li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p>
</li>
</ul>
<h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><ul>
<li><p>数据库提供的4种事务隔离级别：</p>
<p><img src="/2020/02/28/JDBC/1555586275271.png" alt="1555586275271"></p>
</li>
<li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p>
</li>
</ul>
<ul>
<li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li>
</ul>
<h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 在MySql中设置隔离级别</h4><ul>
<li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p>
</li>
<li><p>查看当前的隔离级别: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置当前 mySQL 连接的隔离级别:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据库系统的全局的隔离级别:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure>
</li>
<li><p>补充操作：</p>
<ul>
<li><p>创建mysql数据库用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user tom identified by &#39;abc123&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>授予权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privileges on *.* to tom@&#39;%&#39;  identified by &#39;abc123&#39;; </span><br><span class="line"></span><br><span class="line"> #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#39;abc123&#39;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h2 id="第7章：DAO及相关实现类"><a href="#第7章：DAO及相关实现类" class="headerlink" title="第7章：DAO及相关实现类"></a>第7章：DAO及相关实现类</h2><ul>
<li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li>
<li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li>
<li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li>
</ul>
<p><img src="/2020/02/28/JDBC/1566726681515.png" alt="1566726681515"></p>
<ul>
<li>层次结构：</li>
</ul>
<p><img src="/2020/02/28/JDBC/1566745811244.png" alt="1566745811244"></p>
<h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HanYanBing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	<span class="comment">// 定义一个变量来接收泛型的类型</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BaseDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取子类的类型</span></span><br><span class="line">		Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">		<span class="comment">// 获取父类的类型</span></span><br><span class="line">		<span class="comment">// getGenericSuperclass()用来获取当前类的父类的类型</span></span><br><span class="line">		<span class="comment">// ParameterizedType表示的是带泛型的类型</span></span><br><span class="line">		ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();</span><br><span class="line">		<span class="comment">// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型</span></span><br><span class="line">		<span class="comment">// 这个方法会返回一个Type的数组</span></span><br><span class="line">		Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">		<span class="comment">// 获取具体的泛型的类型·</span></span><br><span class="line">		<span class="keyword">this</span>.type = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通用的增删改操作</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			count = queryRunner.update(conn, sql, params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取一个对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getBean</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取所有对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getBeanList</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			list = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		Object count = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 调用queryRunner的query方法获取一个单一的值</span></span><br><span class="line">			count = queryRunner.query(conn, sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;(), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库中查询出所有的记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数据库中插入一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库中根据图书的id删除一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据图书的id从数据库中查询出一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据图书的id从数据库中更新一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取带分页的图书信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取带分页和价格范围的图书信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据User对象中的用户名和密码从数据库中获取一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据User对象中的用户名从数据库中获取一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数据库中插入User对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中得到一个List的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">"select id,title,author,price,sales,stock,img_path imgPath from books"</span>;</span><br><span class="line">		beanList = getBeanList(conn,sql);</span><br><span class="line">		<span class="keyword">return</span> beanList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">"insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)"</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">"DELETE FROM books WHERE id = ?"</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用增删改的方法</span></span><br><span class="line">		update(conn,sql, bookId);</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		Book book = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">"select id,title,author,price,sales,stock,img_path imgPath from books where id = ?"</span>;</span><br><span class="line">		book = getBean(conn,sql, bookId);</span><br><span class="line">		<span class="keyword">return</span> book;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">"update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?"</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">		String sql = <span class="string">"select count(*) from books"</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line">		<span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql);</span><br><span class="line">		<span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">		page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">		String sql2 = <span class="string">"select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?"</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line">		<span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">		page.setList(beanList);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">		String sql = <span class="string">"select count(*) from books where price between ? and ?"</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line">		<span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql,minPrice,maxPrice);</span><br><span class="line">		<span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">		page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">		String sql2 = <span class="string">"select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?"</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line">		<span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">		page.setList(beanList);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		User bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">"select id,username,password,email from users where username = ? and password = ?"</span>;</span><br><span class="line">		bean = getBean(conn,sql, user.getUsername(), user.getPassword());</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		User bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">"select id,username,password,email from users where username = ?"</span>;</span><br><span class="line">		bean = getBean(conn,sql, user.getUsername());</span><br><span class="line">		<span class="keyword">return</span> bean != <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//写sql语句</span></span><br><span class="line">		String sql = <span class="string">"insert into users(username,password,email) values(?,?,?)"</span>;</span><br><span class="line">		<span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String title; <span class="comment">// 书名</span></span><br><span class="line">	<span class="keyword">private</span> String author; <span class="comment">// 作者</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> price; <span class="comment">// 价格</span></span><br><span class="line">	<span class="keyword">private</span> Integer sales; <span class="comment">// 销量</span></span><br><span class="line">	<span class="keyword">private</span> Integer stock; <span class="comment">// 库存</span></span><br><span class="line">	<span class="keyword">private</span> String imgPath = <span class="string">"static/img/default.jpg"</span>; <span class="comment">// 封面图片的路径</span></span><br><span class="line">	<span class="comment">//构造器，get()，set()，toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页码类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_SIZE = <span class="number">4</span>; <span class="comment">// 每页显示的记录数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> pageNo; <span class="comment">// 当前页</span></span><br><span class="line"><span class="comment">//	private int totalPageNo; // 总页数，通过计算得到</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> totalRecord; <span class="comment">// 总记录数，通过查询数据库得到</span></span><br></pre></td></tr></table></figure>

<h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure>



<h2 id="第8章：数据库连接池"><a href="#第8章：数据库连接池" class="headerlink" title="第8章：数据库连接池"></a>第8章：数据库连接池</h2><h3 id="8-1-JDBC数据库连接池的必要性"><a href="#8-1-JDBC数据库连接池的必要性" class="headerlink" title="8.1 JDBC数据库连接池的必要性"></a>8.1 JDBC数据库连接池的必要性</h3><ul>
<li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p>
<ul>
<li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li>
<li><strong>进行sql操作</strong></li>
<li><strong>断开数据库连接</strong></li>
</ul>
</li>
<li><p>这种模式开发，存在的问题:</p>
<ul>
<li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li>
</ul>
</li>
</ul>
<h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul>
<li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
</li>
<li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p>
</li>
<li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p>
</li>
<li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
</li>
</ul>
<p><img src="/2020/02/28/JDBC/1555593464033.png" alt="1555593464033"></p>
<ul>
<li><strong>工作原理：</strong></li>
</ul>
<p><img src="/2020/02/28/JDBC/1555593598606.png" alt="1555593598606"></p>
<ul>
<li><p><strong>数据库连接池技术的优点</strong></p>
<p><strong>1. 资源重用</strong></p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p><strong>2. 更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p>
<p><strong>3. 新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p>
<p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p>
</li>
</ul>
<h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul>
<li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul>
<li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li>
<li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li>
<li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li>
<li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li>
</ul>
</li>
<li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li>
<li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li>
<li>特别注意：<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
</li>
</ul>
<h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><ul>
<li>获取连接方式一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">	cpds.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>); </span><br><span class="line">	cpds.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test"</span>);</span><br><span class="line">	cpds.setUser(<span class="string">"root"</span>);</span><br><span class="line">	cpds.setPassword(<span class="string">"abc123"</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//	cpds.setMaxPoolSize(100);</span></span><br><span class="line">	</span><br><span class="line">	Connection conn = cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>获取连接方式二</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource cpds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">"helloc3p0"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">	Connection conn = cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【c3p0-config.xml】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">"helloc3p0"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatementsPerConnection"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-2-DBCP数据库连接池"><a href="#8-3-2-DBCP数据库连接池" class="headerlink" title="8.3.2 DBCP数据库连接池"></a>8.3.2 DBCP数据库连接池</h4><ul>
<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
<li>配置属性说明</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>initialSize</td>
<td>0</td>
<td>连接池启动时创建的初始化连接数量</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>连接池中可同时连接的最大的连接数</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td>
</tr>
<tr>
<td>minIdle</td>
<td>0</td>
<td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td>
</tr>
<tr>
<td>maxWait</td>
<td>无限制</td>
<td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>开启池的Statement是否prepared</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>无限制</td>
<td>开启池的prepared 后的同时最大连接数</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>300</td>
<td>超过时间限制，回收没有用(废弃)的连接</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>false</td>
<td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td>
</tr>
</tbody></table>
<ul>
<li>获取连接方式一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	BasicDataSource source = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">		</span><br><span class="line">	source.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">	source.setUrl(<span class="string">"jdbc:mysql:///test"</span>);</span><br><span class="line">	source.setUsername(<span class="string">"root"</span>);</span><br><span class="line">	source.setPassword(<span class="string">"abc123"</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	source.setInitialSize(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取连接方式二：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource source = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">		</span><br><span class="line">		InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream("dbcp.properties");</span><br><span class="line">			</span><br><span class="line">		pros.load(is);</span><br><span class="line">		<span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">		source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【dbcp.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Properties pro = new Properties();		 pro.load(TestDruid.class.getClassLoader().getResourceAsStream("druid.properties"));</span><br><span class="line">		DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">		Connection conn = ds.getConnection();</span><br><span class="line">		System.out.println(conn);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【druid.properties】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">maxWait=<span class="number">1000</span></span><br><span class="line">filters=wall</span><br></pre></td></tr></table></figure>

<ul>
<li>详细配置参数：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>配置</strong></th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter" target="_blank" rel="noopener">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
<h2 id="第9章：Apache-DBUtils实现CRUD操作"><a href="#第9章：Apache-DBUtils实现CRUD操作" class="headerlink" title="第9章：Apache-DBUtils实现CRUD操作"></a>第9章：Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils简介"><a href="#9-1-Apache-DBUtils简介" class="headerlink" title="9.1 Apache-DBUtils简介"></a>9.1 Apache-DBUtils简介</h3><ul>
<li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p>
</li>
<li><p>API介绍：</p>
<ul>
<li>org.apache.commons.dbutils.QueryRunner</li>
<li>org.apache.commons.dbutils.ResultSetHandler</li>
<li>工具类：org.apache.commons.dbutils.DbUtils   </li>
</ul>
</li>
<li><p>API包说明：</p>
</li>
</ul>
<p><img src="/2020/02/28/JDBC/1555595163263.png" alt="1555595163263"></p>
<p><img src="/2020/02/28/JDBC/1555595198644.png" alt="1555595198644"></p>
<h3 id="9-2-主要API的使用"><a href="#9-2-主要API的使用" class="headerlink" title="9.2 主要API的使用"></a>9.2 主要API的使用</h3><h4 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h4><ul>
<li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul>
<li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li>
<li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li>
<li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li>
<li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li>
<li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li>
<li>public static void rollbackAndClose(Connection conn)throws SQLException</li>
<li>rollbackAndCloseQuietly(Connection)</li>
<li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li>
</ul>
</li>
</ul>
<h4 id="9-2-2-QueryRunner类"><a href="#9-2-2-QueryRunner类" class="headerlink" title="9.2.2 QueryRunner类"></a>9.2.2 QueryRunner类</h4><ul>
<li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p>
</li>
<li><p>QueryRunner类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
</li>
<li><p>QueryRunner类的主要方法：</p>
<ul>
<li><strong>更新</strong><ul>
<li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li>
<li>……</li>
</ul>
</li>
<li><strong>插入</strong><ul>
<li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</T></T></li>
<li>….</li>
</ul>
</li>
<li><strong>批处理</strong><ul>
<li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li>
<li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</T></T></li>
<li>…..</li>
</ul>
</li>
<li><strong>查询</strong><ul>
<li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li>
<li>…… </li>
</ul>
</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">	String sql = <span class="string">"insert into customers(name,email,birth)values(?,?,?)"</span>;</span><br><span class="line">	<span class="keyword">int</span> count = runner.update(conn, sql, <span class="string">"何成飞"</span>, <span class="string">"he@qq.com"</span>, <span class="string">"1992-09-08"</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">"添加了"</span> + count + <span class="string">"条记录"</span>);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">	String sql = <span class="string">"delete from customers where id &lt; ?"</span>;</span><br><span class="line">	<span class="keyword">int</span> count = runner.update(conn, sql,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">"删除了"</span> + count + <span class="string">"条记录"</span>);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-2-3-ResultSetHandler接口及实现类"><a href="#9-2-3-ResultSetHandler接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler接口及实现类"></a>9.2.3 ResultSetHandler接口及实现类</h4><ul>
<li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>
</li>
<li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p>
</li>
<li><p>接口的主要实现类：</p>
<ul>
<li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li>
<li><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li>
<li><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li>
<li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li>
<li><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li>
<li><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li>
<li><strong>ScalarHandler：</strong>查询单个值对象</li>
</ul>
</li>
</ul>
<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">"select id,name,email,birth from customers where id = ?"</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">	System.out.println(customer);	</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">"select id,name,email,birth from customers where id &lt; ?"</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Customer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">	list.forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">"select id,name,email,birth from customers where id = ?"</span>;</span><br><span class="line">		</span><br><span class="line">	ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"handle"</span>);</span><br><span class="line"><span class="comment">//			return new Customer(1,"Tom","tom@126.com",new Date(123323432L));</span></span><br><span class="line">				</span><br><span class="line">			<span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">				<span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">				String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">				String email = rs.getString(<span class="string">"email"</span>);</span><br><span class="line">				Date birth = rs.getDate(<span class="string">"birth"</span>);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">		</span><br><span class="line">	Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">		</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"> * 使用ScalarHandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//测试一：</span></span><br><span class="line"><span class="comment">//	String sql = "select count(*) from customers where id &lt; ?";</span></span><br><span class="line"><span class="comment">//	ScalarHandler handler = new ScalarHandler();</span></span><br><span class="line"><span class="comment">//	long count = (long) runner.query(conn, sql, handler, 20);</span></span><br><span class="line"><span class="comment">//	System.out.println(count);</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">//测试二：</span></span><br><span class="line">	String sql = <span class="string">"select max(birth) from customers"</span>;</span><br><span class="line">	ScalarHandler handler = <span class="keyword">new</span> ScalarHandler();</span><br><span class="line">	Date birth = (Date) runner.query(conn, sql, handler);</span><br><span class="line">	System.out.println(birth);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateWithTx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//1.获取连接的操作（</span></span><br><span class="line">		<span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line">		<span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid</span></span><br><span class="line">		<span class="comment">//2.对数据表进行一系列CRUD操作</span></span><br><span class="line">		<span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)</span></span><br><span class="line"><span class="comment">//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line">		<span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类</span></span><br><span class="line">			</span><br><span class="line">		<span class="comment">//提交数据</span></span><br><span class="line">		conn.commit();</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//回滚数据</span></span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//3.关闭连接等操作</span></span><br><span class="line">		<span class="comment">//① JDBCUtils.closeResource();</span></span><br><span class="line">		<span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作</span></span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java语法</category>
      </categories>
      <tags>
        <tag>java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 9大组件概述</title>
    <url>/2020/02/28/Spring%20MVC%209%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="Spring-MVC-9大组件概述"><a href="#Spring-MVC-9大组件概述" class="headerlink" title="Spring MVC 9大组件概述"></a>Spring MVC 9大组件概述</h1><p><a href="https://www.cnblogs.com/baichunyu/articles/11157337.html" target="_blank" rel="noopener">https://www.cnblogs.com/baichunyu/articles/11157337.html</a></p>
<hr>
<p>　<strong>SpringMVC中的Servlet一共有三个层次，分别是HttpServletBean、FrameworkServlet和 DispatcherServlet。HttpServletBean直接继承自java的HttpServlet，其作用是将Servlet中配置的参数设置到相应的属性；FrameworkServlet初始化了WebApplicationContext，DispatcherServlet初始化了自身的9个组件。</strong><br>**　　本篇博客的内容就是对9个组件做个简单概述。**<br>**　　在学习9个组件之前，我们需要先了解Handler的概念，也就是处理器。它直接应对着MVC中的C也就是Controller层，它的具体表现形式有很多，可以是类，也可以是方法。在Controller层中@RequestMapping标注的所有方法都可以看成是一个Handler，只要可以实际处理请求就可以是Handler。**</p>
<h2 id="（1）HandlerMapping"><a href="#（1）HandlerMapping" class="headerlink" title="（1）HandlerMapping"></a>（1）HandlerMapping</h2><p>　　是用来查找Handler的。在SpringMVC中会有很多请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个Handler进行处理呢？这就是HandlerMapping需要做的事。<br>public interface HandlerMapping<br>{<br>     HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;<br> }<br>　　我们可以看到HandlerMapping接口中只定义了一个方法，就是通过request找到HandlerExecutionChain，而HandlerExecutionChain包装了一个Handler和一组Interceptors。</p>
<h2 id="（2）-HandlerAdapter"><a href="#（2）-HandlerAdapter" class="headerlink" title="（2） HandlerAdapter"></a>（2） HandlerAdapter</h2><p>　　从名字上看，它就是一个适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就ok，但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情。任意形式的Handler通过使用适配器，可以“转换”成固定形式，然后交给Servlet来处理。每种Handler都要有对应的HandlerAdapter才能处理请求。<br>　　 <a id="more"></a><br><img src="https://cdn.nlark.com/yuque/0/2020/gif/539392/1579139171730-aee1630d-fb64-4b93-8467-3992e214d47f.gif#align=left&display=inline&height=20&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20" alt><br> 1 public interface HandlerAdapter {<br> 2<br> 3     /**<br> 4      * 判断是否支持传入的handler<br> 5      <em>/<br> 6     boolean supports(Object handler);<br> 7<br> 8     /*</em><br> 9      * 使用给定的handler处理请求<br>10      <em>/<br>11     ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;<br>12<br>13     /*</em><br>14      * 返回上次修改时间，可以返回-1表示不支持<br>15      */<br>16     long getLastModified(HttpServletRequest request, Object handler);<br>17<br>18 }<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/539392/1579139171721-e0637c97-0630-4b86-addc-b0c01413e80a.gif#align=left&display=inline&height=20&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20" alt></p>
<h2 id="（3）HandlerExceptionResolver"><a href="#（3）HandlerExceptionResolver" class="headerlink" title="（3）HandlerExceptionResolver"></a>（3）HandlerExceptionResolver</h2><p>　　其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。具体来说，此组件的作用是根据异常设置ModelAndView，之后再交给render方法进行渲染。我们来看下HandlerExceptionResolver的接口定义：<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/539392/1579139171723-83482235-7323-4f4b-abc3-79af94aecf33.gif#align=left&display=inline&height=20&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20" alt><br>1 public interface HandlerExceptionResolver {<br>2<br>3     ModelAndView resolveException(<br>4             HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);<br>5<br>6 }<br><img src="https://cdn.nlark.com/yuque/0/2020/gif/539392/1579139171744-bb1757fa-0103-427b-b7a1-f0e37c369222.gif#align=left&display=inline&height=20&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20" alt><br>　　从上面的分析中我们可以知道HandlerExceptionResolver只能处理页面渲染之前的异常，页面渲染过程中的异常，它是不能处理的，这时可以让容器跳转到指定的错误页面来处理异常。</p>
<h2 id="（4）ViewResolver"><a href="#（4）ViewResolver" class="headerlink" title="（4）ViewResolver"></a>（4）ViewResolver</h2><p>　　ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。这里就有两个关键问题：使用哪个模板？用什么技术（规则）填入参数？这其实是ViewResolver主要要做的工作，ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交由不同的视图自己完成。<br>1 public interface ViewResolver {<br>2<br>3     View resolveViewName(String viewName, Locale locale) throws Exception;<br>4<br>5 }</p>
<h2 id="（5）RequestToViewNameTranslator"><a href="#（5）RequestToViewNameTranslator" class="headerlink" title="（5）RequestToViewNameTranslator"></a>（5）RequestToViewNameTranslator</h2><p>　　ViewName是根据ViewName查找View，但有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要RequestToViewNameTranslator从request中找到默认的View了。如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。RequestToViewNameTranslator在Spring MVC容器里只可以配置一个，所以所有request到ViewName的转换规则都要在一个Translator里面全部实现。<br>1 public interface RequestToViewNameTranslator {<br>2<br>3     String getViewName(HttpServletRequest request) throws Exception;<br>4<br>5 }</p>
<h2 id="（6）LocaleResolver"><a href="#（6）LocaleResolver" class="headerlink" title="（6）LocaleResolver"></a>（6）LocaleResolver</h2><p>　　解析视图需要两个参数：一是视图名，另一个是Locale。视图名是处理器返回的，Locale是从哪里来的？这就是LocaleResolver要做的事情。LocaleResolver用于从request解析出Locale，Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。</p>
<h2 id="（7）ThemeResolver"><a href="#（7）ThemeResolver" class="headerlink" title="（7）ThemeResolver"></a>（7）ThemeResolver</h2><p>　　用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，同一个主题不同区域也可以显示不同的风格。SpringMVC中跟主题相关的类有 ThemeResolver、ThemeSource和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是ThemeSource的工作。最后从主题中获取资源就可以了。</p>
<h2 id="（8）MultipartResolver"><a href="#（8）MultipartResolver" class="headerlink" title="（8）MultipartResolver"></a>（8）MultipartResolver</h2><p>　　用于处理上传请求。处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。</p>
<h2 id="（9）FlashMapManager"><a href="#（9）FlashMapManager" class="headerlink" title="（9）FlashMapManager"></a>（9）FlashMapManager</h2><p>　　用来管理FlashMap的，FlashMap主要用在redirect中传递参数。</p>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC接收与响应json数据的几种方式</title>
    <url>/2020/02/28/SpringMVC%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%93%8D%E5%BA%94json%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="SpringMVC接收与响应json数据的几种方式"><a href="#SpringMVC接收与响应json数据的几种方式" class="headerlink" title="SpringMVC接收与响应json数据的几种方式"></a>SpringMVC接收与响应json数据的几种方式</h1><p>前后端的数据交互，除了通过form表单进行提交外，也可以通过ajax向后端传递和接收json格式数据（这种方式可以实现请求数据和页面分离）<br> <a id="more"></a><br><a href="https://m.jb51.net/article/157660.htm" target="_blank" rel="noopener">https://m.jb51.net/article/157660.htm</a></p>
<h1 id="详解SpringMVC-RequestBody接收Json对象字符串"><a href="#详解SpringMVC-RequestBody接收Json对象字符串" class="headerlink" title="详解SpringMVC @RequestBody接收Json对象字符串"></a>详解SpringMVC @RequestBody接收Json对象字符串</h1><p><a href="https://m.jb51.net/article/102693.htm" target="_blank" rel="noopener">https://m.jb51.net/article/102693.htm</a></p>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>spring概述</title>
    <url>/2020/02/28/spring%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="spring概述"><a href="#spring概述" class="headerlink" title="spring概述"></a>spring概述</h1><p>Spring是一个开源框架，它由<a href="https://baike.baidu.com/item/Rod%20Johnson" target="_blank" rel="noopener">Rod Johnson</a>创建。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。<br><strong>Spring是一个轻量级的**</strong>控制反转(IoC)<strong>**和面向切面(AOP)的容器框架。</strong></p>
<ul>
<li>轻量——从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</li>
<li>控制反转——Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</li>
<li>面向切面——Spring提供了<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">面向切面编程</a>的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</li>
<li>容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</li>
<li>框架——Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</li>
</ul>
<p>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p>
<p>组件化：组件与组件之间没关系，但是通过拼接实现功能，降低了耦合，</p>
<h2 id="Spring框架组成"><a href="#Spring框架组成" class="headerlink" title="Spring框架组成"></a>Spring框架组成</h2><p>由七个定义明确的模块组成</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/539392/1578657208540-08befd83-ab7a-4f6f-996e-f5c3683d7b68.jpeg#align=left&display=inline&height=415&originHeight=415&originWidth=784&size=0&status=done&style=none&width=784" alt></p>
<p>如果作为一个整体，这些模块为你提供了开发企业应用所需的一切。但你不必将应用完全基于Spring框架。你可以自由地挑选适合你的应用的模块而忽略其余的模块。<br>就像你所看到的，所有的Spring模块都是在核心容器之上构建的。容器定义了Bean是如何创建、配置和管理的——更多的Spring细节。当你配置你的应用时，你会潜在地使用这些类。但是作为一名开发者，你最可能对影响容器所提供的服务的其它模块感兴趣。这些模块将会为你提供用于构建应用服务的框架，例如AOP和持久性。</p>
<h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><p>这是Spring框架最基础的部分，它提供了依赖注入（DependencyInjection）特征来实现容器对Bean的管理。这里最基本的概念是BeanFactory，它是任何Spring应用的核心。BeanFactory是工厂模式的一个实现，它使用IoC将应用配置和依赖说明从实际的应用代码中分离出来。</p>
 <a id="more"></a>

<h3 id="应用上下文（Context）模块"><a href="#应用上下文（Context）模块" class="headerlink" title="应用上下文（Context）模块"></a>应用上下文（Context）模块</h3><p>核心模块的BeanFactory使Spring成为一个容器，而上下文模块使它成为一个框架。这个模块扩展了BeanFactory的概念，增加了对国际化（I18N）消息、事件传播以及验证的支持。<br>另外，这个模块提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括了对模版框架例如Velocity和FreeMarker集成的支持。</p>
<h3 id="Spring的AOP模块"><a href="#Spring的AOP模块" class="headerlink" title="Spring的AOP模块"></a>Spring的AOP模块</h3><p>Spring在它的AOP模块中提供了对面向切面编程的丰富支持。这个模块是在Spring应用中实现切面编程的基础。为了确保Spring与其它AOP框架的互用性，Spring的AOP支持基于AOP联盟定义的API。AOP联盟是一个开源项目，它的目标是通过定义一组共同的接口和组件来促进AOP的使用以及不同的AOP实现之间的互用性。通过访问他们的站点，你可以找到关于AOP联盟的更多内容。<br>Spring的AOP模块也将元数据编程引入了Spring。使用Spring的元数据支持，你可以为你的源代码增加注释，指示Spring在何处以及如何应用切面函数。</p>
<h3 id="JDBC抽象和DAO模块"><a href="#JDBC抽象和DAO模块" class="headerlink" title="JDBC抽象和DAO模块"></a>JDBC抽象和DAO模块</h3><p>使用JDBC经常导致大量的重复代码，取得连接、创建语句、处理结果集，然后关闭连接。Spring的JDBC和DAO模块抽取了这些重复代码，因此你可以保持你的数据库访问代码干净简洁，并且可以防止因关闭数据库资源失败而引起的问题。<br>这个模块还在几种数据库服务器给出的错误消息之上建立了一个有意义的异常层。使你不用再试图破译神秘的私有的SQL错误消息！<br>另外，这个模块还使用了Spring的AOP模块为Spring应用中的对象提供了事务管理服务。</p>
<h3 id="对象-关系映射集成模块"><a href="#对象-关系映射集成模块" class="headerlink" title="对象/关系映射集成模块"></a>对象/关系映射集成模块</h3><p>对那些更喜欢使用对象/关系映射工具而不是直接使用JDBC的人，Spring提供了ORM模块。Spring并不试图实现它自己的ORM解决方案，而是为几种流行的ORM框架提供了集成方案，包括Hibernate、JDO和iBATIS SQL映射。Spring的事务管理支持这些ORM框架中的每一个也包括JDBC。</p>
<h3 id="Spring的Web模块"><a href="#Spring的Web模块" class="headerlink" title="Spring的Web模块"></a>Spring的Web模块</h3><p>Web上下文模块建立于应用上下文模块之上，提供了一个适合于Web应用的上下文。另外，这个模块还提供了一些面向服务支持。例如：实现文件上传的multipart请求，它也提供了Spring和其它Web框架的集成，比如Struts、WebWork。</p>
<h3 id="Spring的MVC框架"><a href="#Spring的MVC框架" class="headerlink" title="Spring的MVC框架"></a>Spring的MVC框架</h3><p>Spring为构建Web应用提供了一个功能全面的MVC框架。虽然Spring可以很容易地与其它MVC框架集成，例如Struts，但Spring的MVC框架使用IoC对控制逻辑和业务对象提供了完全的分离。<br>它也允许你声明性地将请求参数绑定到你的业务对象中，此外，Spring的MVC框架还可以利用Spring的任何其它服务，例如国际化信息与验证。</p>
<h1 id="EJB（spring-javabean精简实现）"><a href="#EJB（spring-javabean精简实现）" class="headerlink" title="EJB（spring javabean精简实现）"></a>EJB（spring javabean精简实现）</h1><p>企业级JavaBean（Enterprise JavaBean, EJB）是一个用来构筑企业级应用的服务器端可被管理组件。<br>ava的一个特性，数据与行为相分离。数据就是成员变量，行为就是setter和getter方法<br>JavaBean是Java中开发的可以跨平台的重要组件，在JSP中常用来封装业务逻辑和数据库操作。<br><strong>JavaBeans是Java中一种特殊的类，可以将多个对象封装到一个对象（bean）中。特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。名称中的“Bean”是用于Java的可重用软件组件的惯用叫法。</strong><br><strong>—以上源自维基百科</strong><br>JavaBean是一种特殊的Java类，即：有公共的 无参的  构造方法，只有get和set方法的java类的对象。</p>
<p>JavaBean功能上分为两类：</p>
<ul>
<li>封装数据</li>
<li>封装业务</li>
</ul>
<p>JavaBean一般情况下要满足以下要求：<br> 1.是一个公有类，并提供无参的构造方法。<br> 2.属性私有。</p>
<p> 3.具有公有的setter和getter方法。</p>
<p> 4.这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）<br>JavaBean的应用：</p>
<h4 id="JavaBean封装数据："><a href="#JavaBean封装数据：" class="headerlink" title="JavaBean封装数据："></a>JavaBean封装数据：</h4><p> 实际上就是数据库中某一张表的字段进行封装，每一个属性都要与数据库表中字段一一对应。</p>
<h4 id="JavaBean封装业务："><a href="#JavaBean封装业务：" class="headerlink" title="JavaBean封装业务："></a>JavaBean封装业务：</h4><p> 封装数据的JavaBean一般都会有一个封装该类的<br>    业务逻辑和操作与之对应。如：Dao层中的类。<br> service层用于存放业务逻辑相关的操作。</p>
<p> service层中的接口和类对Dao类的方法实现了封装和调用。</p>
<h3 id="POJO（Plain-Ordinary-Java-Object）："><a href="#POJO（Plain-Ordinary-Java-Object）：" class="headerlink" title="POJO（Plain Ordinary Java Object）："></a>POJO（Plain Ordinary Java Object）：</h3><p>一开始我认为POJO是简单的JavaBean，里面只有封装数据，没有任何业务逻辑代码。<br>但其实它们两个之间是有区别的，不然为什么会出现POJO和JavaBean这个不同的词语。</p>
<p>参考文章：<a href="https://blog.csdn.net/chenchunlin526/article/details/69939337" target="_blank" rel="noopener">https://blog.csdn.net/chenchunlin526/article/details/69939337</a></p>
<p>总结下来区别就是</p>
<p>POJO是一个简单的、普通Java对象，它包含业务逻辑处理或持久化逻辑等，但不是JavaBean、EntityBean等，不具有任何特殊角色，不继承或不实现任何其它Java框架的类或接口。但是，当一个POJO可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个JavaBean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么传统JavaBean和Spring的Bean区别在哪里呢？<br>javabean已经很少人用了<br>springbean可以说是javabean的发展, 但已经完全不是一回事儿了</p>
<p>1.用处不同：传统javabean更多地作为值传递参数，而spring中的bean用处几乎无处不在，任何组件都可以被称为bean。<br>2.写法不同：传统javabean作为值对象，要求每个属性都提供getter和setter方法；但spring中的bean只需为接受设值注入的属性提供setter方法。</p>
<p>3.生命周期不同：传统javabean作为值对象传递，不接受任何容器管理其生命周期；spring中的bean有spring管理其生命周期行为。</p>
<p><strong>所有可以被spring容器实例化并管理的java类都可以称为bean。</strong></p>
<p>原来服务器处理页面返回的值都是直接使用request对象，后来增加了javabean来管理对象，所有页面值只要是和javabean对应，就可以用类.GET属性方法来获取值。javabean不只可以传参数，也可以处理数据，相当与把一个服务器执行的类放到了页面上，使对象管理相对不那么乱（对比asp的时候所有内容都在页面上完成）。</p>
<p>spring中的bean，是通过配置文件、javaconfig等的设置，有spring自动实例化，用完后自动销毁的对象。让我们只需要在用的时候使用对象就可以，不用考虑如果创建类对象（这就是spring的注入）。一般是用在服务器端代码的执行上。</p>
<h2 id="Spring-Bean与javaBean区别："><a href="#Spring-Bean与javaBean区别：" class="headerlink" title="Spring Bean与javaBean区别："></a>Spring Bean与javaBean区别：</h2><p>规范：<br><strong>传统的</strong>java应用中，javabean遵循一些规范，规范如下：<br>1、这个类必须具有一个公共的(public)无参构造函数；<br>2、所有属性私有化（private）；<br>3、私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。<br>4、这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）<br><strong>Spring</strong>容器对Bean没有特殊要求，不像javaBean一样遵循一些规范（不过对于通过设置方法注入的Bean，一定要提供setter方法）<br>用处：<br><strong>传统</strong>javaBean更多地作为值传递参数，<br><strong>而Spring中的bean</strong>用处几乎无处不在，任何组件都可以被称其bean。<br>生命周期：<br>在<strong>传统的</strong>java应用中，bean的生命周期很简单。使用java关键字new进行bean实例化，然后该bean就可以使用了，一旦该bean不再使用，则由java自动进行垃圾回收。<br><strong>Spring中的Bean</strong>由Spring容器管理其生命周期行动，较为复杂。<br>传统java：子类是父类的加强，是一种特殊的父类。<br>Spring中bean：子bean和父bean可以是不同的类型。<br>传统java：继承是类与类之间的关系，主要表现为方法及属性的延续。<br>Spring中的bean：Spring中的bean的继承是实例之间关系，主要表现为参数值得延续。<br>传统java：子类实例完全当成父类实例使用。<br>Spring中bean：子bean不可作父bean使用。</p>
<h1 id="单例设计模式之容器单例"><a href="#单例设计模式之容器单例" class="headerlink" title="单例设计模式之容器单例"></a>单例设计模式之容器单例</h1><h1 id="容器工厂（原型-amp-单例）"><a href="#容器工厂（原型-amp-单例）" class="headerlink" title="容器工厂（原型&amp;单例）"></a><a href="https://www.cnblogs.com/javaLin/p/7906434.html" target="_blank" rel="noopener">容器工厂（原型&amp;单例）</a></h1><h2 id="单例模式与原型模式"><a href="#单例模式与原型模式" class="headerlink" title="单例模式与原型模式"></a>单例模式与原型模式</h2><h3 id="1单例模式"><a href="#1单例模式" class="headerlink" title="1单例模式"></a>1单例模式</h3><p>单列模式分为饿汉式与懒汉式<br>饿汉式式程序一启动就加载，静态方法中初始，但是如果创建时间过长，会拉长启动时间<br>懒汉式是用的时候才初始化，但是如果是并发调用，那就不是单例了。在方法面前加同步关键词会严重的浪费性能<br>最优的方案：是创建一个内部类。调用静态初始化方法的时候，初始化内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDto</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleDto <span class="title">newInstances</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> LazyClass.singleDto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyClass</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingleDto singleDto = <span class="keyword">new</span> SingleDto();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2原型模式"><a href="#2原型模式" class="headerlink" title="2原型模式"></a>2原型模式</h3><p>存在一个对象，每次新建对象都是拷贝这个对象的属性值分为浅复制与深复制区别在于对象里面的引用类型对象属性是否是同一个;</p>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>关于springMVC中@ModelAttribute注解的隐含model属性名</title>
    <url>/2020/02/28/%E5%85%B3%E4%BA%8EspringMVC%E4%B8%AD@ModelAttribute%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%9A%90%E5%90%ABmodel%E5%B1%9E%E6%80%A7%E5%90%8D/</url>
    <content><![CDATA[<h1 id="关于springMVC中-ModelAttribute注解的隐含model属性名"><a href="#关于springMVC中-ModelAttribute注解的隐含model属性名" class="headerlink" title="关于springMVC中@ModelAttribute注解的隐含model属性名"></a>关于springMVC中@ModelAttribute注解的隐含model属性名</h1><p><a href="https://blog.csdn.net/u014645508/article/details/88871482" target="_blank" rel="noopener">https://blog.csdn.net/u014645508/article/details/88871482</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试ModelAttribute注解；</span></span><br><span class="line"><span class="comment"> * 使用场景：书城的图书修改为例；</span></span><br><span class="line"><span class="comment"> * 1）页面端；</span></span><br><span class="line"><span class="comment"> * 		显示要修改的图书的信息，图书的所有字段都在</span></span><br><span class="line"><span class="comment"> * 2）servlet收到修改请求，调用dao；</span></span><br><span class="line"><span class="comment"> * 		String sql="update bs_book set title=?,</span></span><br><span class="line"><span class="comment"> * 					author=?,price=?,</span></span><br><span class="line"><span class="comment"> * 					sales=?,stock=?,img_path=? </span></span><br><span class="line"><span class="comment"> * 				where id=?";</span></span><br><span class="line"><span class="comment"> * 3）实际场景？</span></span><br><span class="line"><span class="comment"> * 		并不是全字段修改；只会修改部分字段，以修改用户信息为例；</span></span><br><span class="line"><span class="comment"> * 		username  password  address;</span></span><br><span class="line"><span class="comment"> * 		1）、不修改的字段可以在页面进行展示但是不要提供修改输入框；</span></span><br><span class="line"><span class="comment"> * 		2）、为了简单，Controller直接在参数位置来写Book对象</span></span><br><span class="line"><span class="comment"> * 		3）、SpringMVC为我们自动封装book；（没有带的值是null）</span></span><br><span class="line"><span class="comment"> * 		4）、如果接下来调用了一个全字段更新的dao操作；会将其他的字段可能变为null；</span></span><br><span class="line"><span class="comment"> * 			sql = "update bs_book set"</span></span><br><span class="line"><span class="comment"> * 			if(book.getBookName())&#123;</span></span><br><span class="line"><span class="comment"> * 				sql +="bookName=?,"</span></span><br><span class="line"><span class="comment"> * 			&#125;</span></span><br><span class="line"><span class="comment"> * 			if(book.getPrice())&#123;</span></span><br><span class="line"><span class="comment"> * 				sql +="price=?"</span></span><br><span class="line"><span class="comment"> * 			&#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4）、如何能保证全字段更新的时候，只更新了页面携带的数据；</span></span><br><span class="line"><span class="comment"> * 		1）、修改dao；代价大？</span></span><br><span class="line"><span class="comment"> * 		2）、Book对象是如何封装的？</span></span><br><span class="line"><span class="comment"> * 			1）、SpringMVC创建一个book对象，每个属性都有默认值，bookName就是null；</span></span><br><span class="line"><span class="comment"> * 				1、让SpringMVC别创建book对象，直接从数据库中先取出一个id=100的book对象的信息</span></span><br><span class="line"><span class="comment"> * 				2、Book [id=100, bookName=西游记, author=张三, stock=12, sales=32, price=98.98]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 			2）、将请求中所有与book对应的属性一一设置过来；</span></span><br><span class="line"><span class="comment"> * 				3、使用刚才从数据库取出的book对象，给它 的里面设置值；（请求参数带了哪些值就覆盖之前的值）</span></span><br><span class="line"><span class="comment"> * 				4、带了的字段就改为携带的值，没带的字段就保持之前的值</span></span><br><span class="line"><span class="comment"> * 			3）、调用全字段更新就有问题；</span></span><br><span class="line"><span class="comment"> * 				5、将之前从数据库中查到的对象，并且封装了请求参数的对象。进行保存；</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure>
 <a id="more"></a>
<p>在一个Controller内，被@ModelAttribute标注的方法会在此controller的每个handler方法执行前被执行。因此对于一个controller映射多个URL的用法来说，要谨慎使用<br>　　被@ModelAttribute标注的方法的参数绑定规则和普通handler方法相同。<br>　　可以理解为：</p>
<ol>
<li>请求到达Controller后，不论其他handler方法的RequestMapping值是多少，请求都会路由至被@ModelAttribute标注的方法；</li>
<li>由springMVC再对request执行一次forward，路由至真正的handler方法。</li>
</ol>
<p><strong>@ModelAttribute作用就是传递参数时防止空值传不过来的现象从而在数据库中查找参数进行弥补</strong><br>**    @ModelAttribute<br>    public String getUser(@RequestParam(value=”id”,required=false) Integer id , Map&lt;String,Object&gt; map) {<br>        User user = new User(1,”tome”,11); //模拟数据库传值<br>        map.put(“user”,user);<br>        System.out.println(“修改”+user);<br>       return “success”;<br>**   }**<br><strong>运行流程：</strong></p>
<p><strong>1.执行@ModelAttribute注解修饰的方法：从数据库中取出对象，把对象放到Map中，键为 user</strong></p>
<p><strong>2.SpringMVC从Map中取出User对象，并把表单的请求参数赋给该User对象的对应属性</strong></p>
<p><strong>3.SpringMVC把上述对象传入目标方法的参数。</strong></p>
<p><strong>注意：在2ModelAttribute 修饰的方法中放入到Map时的键需要和目标方法入参类型的第一个字母小写的字符串一致。</strong></p>
<hr>
<p>在 SpringMVC 的 Controller 中使用 <a href>@ModelAttribute </a> 时，应用情况包括下面几种：<br>1、应用在方法上。<br>2、应用在方法的参数上。<br>3、应用在方法上，并且方法也使用了<a href>@RequestMapping </a></p>
<p>首先说明一下，被 <a href>@ModelAttribute </a> 注释的方法会在Controller每个方法执行之前都执行，因此对于一个Controller中包含多个URL的时候，要谨慎使用。</p>
<p>应用在方法上<br>使用@ModelAttribute注解的方法和被@RequestMapping注解的处理方法由很多相似之处:</p>
<p>**  都可以通过入参接收前台提交的数据，而且对入参绑定的设置都是一样的。**<br>**<br>入参绑定的数据如果没有设置可为空，不能接收空数据,否则会报错。**<br>**<br>都可以将数据放入model中，而且对于一次请求,model是共享的,所以在处理方法中的model中存放了@ModelAttribute注解的方法中存放的数据。**</p>
<h1 id="1-使用-ModelAttribute-注解无返回值的方法"><a href="#1-使用-ModelAttribute-注解无返回值的方法" class="headerlink" title="1. 使用 @ModelAttribute  注解无返回值的方法"></a>1. 使用 <a href>@ModelAttribute </a> 注解无返回值的方法</h1><p>举例说明一下：</p>
<p>处理器<br><a href>@ModelAttribute </a><br>public void getUser(@RequestParam(value=”userName”,required=false) String userName,Model model){</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user &#x3D; new User(userName,&quot;123456&quot;);</span><br><span class="line">model.addAttribute(&quot;user&quot;, user);</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>@ModelAttribute注解getUser方法,getUser方法接收前台提交的userName数据,在model中放入user属性和数据。</p>
<p>@RequestMapping(“/testModelAttribute”)<br>public String testModelAttribute(ModelMap model){<br>System.out.println(“testModelAttribute user:”+model.get(“user”));<br>return “success”;<br>}</p>
<p>处理方法的入参引入model，由于是同一个请求,所以这个model中存放了@ModelAttribute注解的方法存入的数据。</p>
<p>测试页面</p>
<form action="testModelAttribute" method="post">
   用户名:<input type="text" name="userName" value="jack">
   <button type="submit">submit</button>
</form>
![](https://cdn.nlark.com/yuque/0/2020/png/539392/1579140287022-ff4409d2-1466-476e-b817-44f057bc1848.png#align=left&display=inline&height=141&originHeight=141&originWidth=488&size=0&status=done&style=none&width=488)
点击提交
![](https://cdn.nlark.com/yuque/0/2020/png/539392/1579140266137-08eb733f-486e-4db5-bfcf-9a9041a891e2.png#align=left&display=inline&height=119&originHeight=119&originWidth=1065&size=0&status=done&style=none&width=1065)

<p>跳转到success.jsp页面</p>
<p>success 访问成功！</p>
<p>${user}<br><img src="https://cdn.nlark.com/yuque/0/2020/png/539392/1579140302033-db6b1f48-b744-4611-82d6-41d0f8b354c0.png#align=left&display=inline&height=191&originHeight=191&originWidth=487&size=0&status=done&style=none&width=487" alt></p>
<h1 id="2-使用-ModelAttribute-注解带有返回值的方法"><a href="#2-使用-ModelAttribute-注解带有返回值的方法" class="headerlink" title="2. 使用 @ModelAttribute  注解带有返回值的方法"></a>2. 使用 <a href>@ModelAttribute </a> 注解带有返回值的方法</h1><p><a href>@ModelAttribute </a><br>public User getUser(@RequestParam(value=”userName”,required=false) String userName){</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user &#x3D; new User(userName,&quot;123456&quot;);</span><br><span class="line">return user;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>这种情况不用显示的向model中放数据，返回的数据会被隐含地放入到model中，在 model 中的 key 为 “返回类型首字母小写”，value 为返回的值。<br>上面相当于model.addAttribute(“user”, user);<br>但是这样会很有局限性，我们可以使用@ModelAttribute的value属性值设置存放在model中的属性key值:</p>
<p>@ModelAttribute(“user1”)<br>public User getUser(@RequestParam(value=”userName”,required=false) String userName,Model model){</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user &#x3D; new User(userName,&quot;123456&quot;);</span><br><span class="line">return user;</span><br></pre></td></tr></table></figure>

<p>}<br>将key值修改为user1,相当于model.addAttribute(“user1”, user);</p>
<p>应用在方法的参数上<br>看代码：</p>
<p>@ModelAttribute(“user”)<br>public User getUser(Model model){</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user &#x3D; new User(&quot;Tom&quot;,&quot;123456&quot;);</span><br><span class="line">return user;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>@RequestMapping(“/testModelAttribute”)<br>public String testModelAttribute(@ModelAttribute(“user”)User user1,Model model){<br>System.out.println(“testModelAttribute User:”+user1);<br>System.out.println(“testModelAttribute model:”+model.toString());<br>return “success”;<br>}</p>
<ul>
<li>测试页面</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/539392/1579140315796-beac0b2e-785d-4008-987e-4079130a7187.png#align=left&display=inline&height=167&originHeight=167&originWidth=564&size=0&status=done&style=none&width=564" alt><br>执行结果:<br><img src="https://cdn.nlark.com/yuque/0/2020/png/539392/1579140324628-e5c8d1cd-cb6d-455a-ad23-72a72d94c3c4.png#align=left&display=inline&height=93&originHeight=93&originWidth=1178&size=0&status=done&style=none&width=1178" alt><br>在处理方法的入参中使用了@ModelAttribute(“user”)User user1<br>执行流程<br>1.springmvc 解析本次请求共享的model（BindingAwareModelMap），<br>由于先被getUser方法处理过，model里面保存了<br>user=User[userName=Tom, password=123456]的数据。<br>2.从model中取出key为user的User对象，并把表单的请求参数赋给这个User对象的对应属性。因为这里前台只传递了 一个参数userName = Jack,所以经过处理这时候的model数据为user=User[userName=Jack, password=123456]userName被覆盖。<br>3.SpringMVC 把上述对象传入目标的参数user1中。</p>
<p>注意:也可以使用@ModelAttribute修饰,这样会默认使用入参类型第一个字母小写去model中匹配</p>
<p>看下下面这种情况:</p>
<p>@ModelAttribute(“user”)<br>public User getUser(Model model){</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user &#x3D; new User(&quot;Tom&quot;,&quot;123456&quot;);</span><br><span class="line">return user;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>首先getUser方法在model中放入key为user的User对象user=User[userName=Tom, password=123456]</p>
<p>@RequestMapping(“/testModelAttribute”)<br>public String testModelAttribute(@ModelAttribute(“newUser”)User user,Model model){<br>System.out.println(“testModelAttribute User:”+user);<br>System.out.println(“testModelAttribute model:”+model.toString());<br>return “success”;<br>}</p>
<p>然后处理方法中使用@ModelAttribute(“newUser”)User user<br>执行流程：<br>1.springmvc 解析本次请求共享的model（BindingAwareModelMap），<br>由于先被getUser方法处理过，model里面保存了<br>user=User[userName=Tom, password=123456]的数据。<br>2.从model中去取key为newUser的User对象，这时候发现没有,那么就去新建一个User对象，并把表单的请求参数赋给这个User对象的对应属性，然后将之绑定到入参中。这时候Model中就存放了两个User对象。因为这里前台只传递了 一个参数userName = Jack,所以经过处理这时候的model数据为user=User[userName=Tom,password=123456]和<br>newUser=User[userName=Jack, password=null]。<br>3.SpringMVC 把上述新建的User对象newUser传入目标的参数user中。</p>
<h1 id="3-应用在方法上，并且方法也使用了-RequestMapping"><a href="#3-应用在方法上，并且方法也使用了-RequestMapping" class="headerlink" title="3.应用在方法上，并且方法也使用了@RequestMapping "></a>3.应用在方法上，并且方法也使用了<a href>@RequestMapping </a></h1><p>如下代码：</p>
<p><a href>@RequestMapping(value </a> = “/test1”)<br>@ModelAttribute(“name1”)<br>public String test1(<a href>@RequestParam(required </a> = false) String name) {<br>return name;<br>}</p>
<p>这种情况下，返回值 String （或者其他对象），就不再是视图了。还是我们上面讲到的放入 Model 中的值，对应的key为注解指定的name1，此时对应的页面就是 <a href>@RequestMapping </a> 的值 test1，交给页面解析后就是test1.jsp</p>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>关于分层，DAO、domain、service、servlet的一些理解</title>
    <url>/2020/02/28/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B1%82%EF%BC%8CDAO%E3%80%81domain%E3%80%81service%E3%80%81servlet%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="关于分层，DAO、domain、service、servlet的一些理解"><a href="#关于分层，DAO、domain、service、servlet的一些理解" class="headerlink" title="关于分层，DAO、domain、service、servlet的一些理解"></a>关于分层，DAO、domain、service、servlet的一些理解</h1><p>domain的概念，通常会分很多层，比如经典的三层架构，控制层、业务层、数据访问层（DAO），此外，还有一个层，就是domain层<br>domain层，通常就是用于放置这个系统中，与数据库中的表，一一对应起来的JavaBean的<br>model层：和domain区别；可能都是javaBean，<br>这个区别是用途不同，domain通常就代表了与数据库表–一一对应的javaBean,<br>model通常代表了不与数据库一一对应的javaBean，但是封装的数据是前端的JS脚本，需要使用的数据<br>domain：只是定义一个javabean。<br>dao：对于数据库的操作，都放到dao层，也就是dao里面通常是对数据库的增、删、改、查等操作。<br>service：完成相应的业务逻辑处理，调用dao层。<br>servlet：完成界面请求、对界面进行跳转等等。servlet调用service层。<br> <a id="more"></a></p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java开发</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础语法-String</title>
    <url>/2020/02/28/article/</url>
    <content><![CDATA[<h1 id="String详解"><a href="#String详解" class="headerlink" title="String详解"></a>String详解</h1><p><strong>在Java中，对于String类出现了两种声明方法：</strong><br>　　一·String str=new String(“Hello”);<br>　　二·String str=”Hello”;<br>　　这两者的区别在于前者是new了一个对象，在堆空间分配了内存，将对象放在里面，str指向该对象；后者则是直接指向了”Hello”字符串。<br>　　举个例子：<br>　　　　　　 String s1=”abcd”;<br>　　　　　　 String s2=”abcd”;<br>　　　　　　 那么s1==s2则会返回true，这是因为==比较的是地址，而在系统优化中，相同的s2会直接指向已有的s1的”abcd”的存放地址。<br>　　　　　　 String s1=new String(“abcd”);<br>　　　　　　 String s2=new String(“abcd”);<br>　　　　　　 这样s1==s2却返回了false，因为s1，s2为两个不同对象，系统分配了不同的存储地址。有关对象的比较用equals()就能解决了。</p>
 <a id="more"></a>

<hr>
<p><a href="https://blog.csdn.net/qq_34490018/article/details/82110578" target="_blank" rel="noopener">https://blog.csdn.net/qq_34490018/article/details/82110578</a></p>
<h1 id="java中String和char"><a href="#java中String和char" class="headerlink" title="java中String和char"></a>java中String和char</h1><p><a href="https://blog.csdn.net/qauchangqingwei/article/details/80831797" target="_blank" rel="noopener">https://blog.csdn.net/qauchangqingwei/article/details/80831797</a></p>
<h2 id="char和string的区别："><a href="#char和string的区别：" class="headerlink" title="char和string的区别："></a>char和string的区别：</h2><ol>
<li>char是表示的是字符，定义的时候用单引号，只能存储一个字符。例如; char=’d’. 而String表示的是字符串，定义的时候用双引号，可以存储一个或者多个字符。例如：String=“we  are neuer”。</li>
<li>char是基本数据类型，而String是个类，属于引用数据类型。String类可以调用方法，具有面向对象的特征。</li>
</ol>
<hr>
<p><a href="https://how2j.cn/k/number-string/number-string-string/324.html#step700" target="_blank" rel="noopener">https://how2j.cn/k/number-string/number-string-string/324.html#step700</a></p>
<h1 id="how2j-数字与字符串系列教材"><a href="#how2j-数字与字符串系列教材" class="headerlink" title="how2j 数字与字符串系列教材"></a>how2j 数字与字符串系列教材</h1><h2 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h2><p>字符串即字符的组合，在Java中，字符串是一个类，所以我们见到的字符串都是对象<br>常见创建字符串手段：</p>
<ol>
<li>每当有一个<strong>字面值</strong>出现的时候，虚拟机就会创建一个字符串</li>
<li>调用String的构造方法创建一个字符串对象</li>
<li>通过+加号进行字符串拼接也会创建新的字符串对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String garen =<span class="string">"盖伦"</span>; <span class="comment">//字面值,虚拟机碰到字面值就会创建一个字符串对象</span></span><br><span class="line">		</span><br><span class="line">		String teemo = <span class="keyword">new</span> String(<span class="string">"提莫"</span>); <span class="comment">//创建了两个字符串对象</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'崔'</span>,<span class="string">'斯'</span>,<span class="string">'特'</span>&#125;;</span><br><span class="line">		</span><br><span class="line">		String hero = <span class="keyword">new</span> String(cs);<span class="comment">//  通过字符数组创建一个字符串对象</span></span><br><span class="line">		</span><br><span class="line">		String hero3 = garen + teemo;<span class="comment">//  通过+加号进行字符串拼接</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>String类是用final修饰的，这意味着String不能被继承，而且所有的成员方法都默认为final方法。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1577086522988-6beb80f6-6527-4c20-891e-b3033c646477.png#align=left&display=inline&height=648&name=image.png&originHeight=795&originWidth=842&size=45678&status=done&style=none&width=686" alt="image.png"></p>
<h2 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h2><p>immutable 是指不可改变的</p>
<p>比如创建了一个字符串对象<br>String garen =”盖伦”;<br><strong>不可改变</strong>的具体含义是指：</p>
<ul>
<li>不能增加长度</li>
<li>不能减少长度</li>
<li>不能插入字符</li>
<li>不能删除字符</li>
<li>不能修改字符</li>
</ul>
<p>也就是说，一旦创建好这个字符串，里面的内容 <strong>永远</strong> 不能改变，String 的表现就像是一个<strong>常量</strong></p>
<h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p>如果不使用字符串格式化，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐<br>使用<strong>字符串格式化</strong>，就可以<strong>简洁明了</strong></p>
<h3 id="1-System-out-format"><a href="#1-System-out-format" class="headerlink" title="1. System.out.format()"></a>1. System.out.format()</h3><p>Java Se5引入的format方法可用于PrintStream或PrintWriter对象，其中也包括System.out对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomhu.format;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">3.141592</span>;</span><br><span class="line">        <span class="comment">// 一般方式</span></span><br><span class="line">        System.out.println(<span class="string">"x = "</span> + x + <span class="string">", y = "</span> + y);</span><br><span class="line">        <span class="comment">// printf()方式</span></span><br><span class="line">        System.out.printf(<span class="string">"x = %d, y = %f\n"</span>, x, y);</span><br><span class="line">        <span class="comment">// format()方式</span></span><br><span class="line">        System.out.format(<span class="string">"x = %d, y = %f\n"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出的结果如下：</span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span>, y = <span class="number">3.141592</span></span><br><span class="line">x = <span class="number">5</span>, y = <span class="number">3.141592</span></span><br><span class="line">x = <span class="number">5</span>, y = <span class="number">3.141592</span></span><br></pre></td></tr></table></figure>

<p>通过下面代码可以看到，format与printf是等价的，它们只需要一个简单的格式化字符串，加上一串参数即可，每个参数对应一个格式修饰符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> format(format, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在format的具体代码中，其实就是调用Formatter的format方法：formatter.format(Locale.getDefault(), format, args);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">format</span><span class="params">(String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">if</span> ((formatter == <span class="keyword">null</span>)</span><br><span class="line">                || (formatter.locale() != Locale.getDefault()))</span><br><span class="line">                formatter = <span class="keyword">new</span> Formatter((Appendable) <span class="keyword">this</span>);</span><br><span class="line">            formatter.format(Locale.getDefault(), format, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Formatter类"><a href="#2-Formatter类" class="headerlink" title="2. Formatter类"></a>2. Formatter类</h3><p>  在Java中，所有新的格式化功能都由Formatter类处理，上述的printf与format也是。可以将Formatter看作是一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。当你创建一个Formatter对象的时候 ，需要向其构造器传递一些信息，告诉它最终的结果将向哪里输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomhu.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Formatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"huhx"</span>;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">22</span>;</span><br><span class="line">        </span><br><span class="line">        Formatter formatter = <span class="keyword">new</span> Formatter(System.out);</span><br><span class="line">        formatter.format(<span class="string">"My name is %s, and my age is %d "</span>, name, age);</span><br><span class="line">        formatter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">My name is huhx, and my age is <span class="number">22</span></span><br></pre></td></tr></table></figure>

<h3 id="3-格式化说明符"><a href="#3-格式化说明符" class="headerlink" title="3.格式化说明符"></a>3.格式化说明符</h3><p>格式化说明符<br>在插入数据时，如果想要控制空格与对齐，就需要精细复杂的格式修饰符，以下是其抽象的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%[argument_index$][flags][width][.precision]conversion</span><br><span class="line"></span><br><span class="line">The optional argument_index is a decimal integer indicating the position of the argument in the argument list. The first argument is referenced by &quot;1$&quot;, the second by &quot;2$&quot;, etc.</span><br><span class="line"></span><br><span class="line">The optional flags is a set of characters that modify the output format. The set of valid flags depends on the conversion.</span><br><span class="line"></span><br><span class="line">The optional width is a non-negative decimal integer indicating the minimum number of characters to be written to the output.</span><br><span class="line"></span><br><span class="line">The optional precision is a non-negative decimal integer usually used to restrict the number of characters. The specific behavior depends on the conversion.</span><br><span class="line"></span><br><span class="line">The required conversion is a character indicating how the argument should be formatted. The set of valid conversions for a given argument depends on the argument&#39;s data type.</span><br></pre></td></tr></table></figure>

<p> 最常见的应用是控制一个域的最小尺寸，这可以通过指定width来实现。Formatter对象通过在必要时添加空格，来确保一个域至少达到某个长度。在默认的情况下，数据是右对齐的，通过”-“标志可以改变对齐的方向。<br>与width相对的是precision(精确度)，它用来指明最大尺寸。width可以应用各种类型的数据转换，并且其行为方式都一样。precision则不一样，不是所有类型的数据都能使用precision，而且，应用于不同的类型的数据转换时，precision的意义也不同。</p>
<ul>
<li>precision应用于String时，它表示打印String时输出字符的最大数量</li>
<li>precision应用于浮点数时，它表示小数点要显示出来的位数。默认是6位小数，如果小数位数过多则舍入，过少则在尾部补零。</li>
<li>由于整数没有小数部分，所以precision不能应用于整数。如果你对整数应用precision，则会触发异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomhu.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Formatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatTest3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Formatter formatter = <span class="keyword">new</span> Formatter(System.out);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        formatter.format(<span class="string">"%-15s %-5s %-10s\n"</span>, <span class="string">"huhx"</span>, <span class="string">"linux"</span>, <span class="string">"liuli"</span>);</span><br><span class="line">        formatter.format(<span class="string">"%-15s %-5s %-10s\n"</span>, <span class="string">"zhangkun"</span>, <span class="string">"yanzi"</span>, <span class="string">"zhangcong"</span>);</span><br><span class="line">        formatter.format(<span class="string">"%-15s %-5s %-10s\n"</span>, <span class="string">"zhangkun"</span>, <span class="string">"yanzhou"</span>, <span class="string">"zhangcong"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        formatter.format(<span class="string">"%-15s %5d %10.2f\n"</span>, <span class="string">"My name is huhx"</span>, <span class="number">5</span>, <span class="number">4.2</span>);</span><br><span class="line">        formatter.format(<span class="string">"%-15.4s %5d %10.2f\n"</span>, <span class="string">"My name is huhx"</span>, <span class="number">5</span>, <span class="number">4.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printTitle();</span><br><span class="line">        System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">        print();</span><br><span class="line">        formatter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line">huhx            linux liuli     </span><br><span class="line">zhangkun        yanzi zhangcong </span><br><span class="line">zhangkun        yanzhou zhangcong </span><br><span class="line">----------------------------</span><br><span class="line">My name is huhx     <span class="number">5</span>       <span class="number">4.20</span></span><br><span class="line">My n                <span class="number">5</span>       <span class="number">4.10</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Formatter转换"><a href="#4-Formatter转换" class="headerlink" title="4. Formatter转换"></a>4. Formatter转换</h3><p>Formatter转换<br> 下面的表格包含了最常用的类型转换：<br>类型转换字符</p>
<table>
<thead>
<tr>
<th>d</th>
<th>整数型(10进制 )</th>
<th>e</th>
<th>浮点数(科学计数)</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>Unicode字符</td>
<td>x</td>
<td>整数(16进制)</td>
</tr>
<tr>
<td>b</td>
<td>Boolean值</td>
<td>h</td>
<td>散列码(16进制)</td>
</tr>
<tr>
<td>s</td>
<td>String</td>
<td>%</td>
<td>字符”%”</td>
</tr>
<tr>
<td>f</td>
<td>浮点数(10进制)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>String.format()是一个static方法，它接受与Formatter.format()方法一样的参数，但返回一个String对象。当你只需要用format方法一次的时候，String.format()还是很方便的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomhu.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">22</span>;</span><br><span class="line">        String name = <span class="string">"huhx"</span>;</span><br><span class="line"></span><br><span class="line">        String info = String.format(<span class="string">"My name is %s and my age is %d"</span>, name, age);</span><br><span class="line">        System.out.println(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的输出结果如下：<br>My name is huhx and my age is 22<br>其实String.format方法的实质还是Formatter.format()，只不过是做了简单封装而已：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Formatter().format(format, args).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="十六进制转换程序"><a href="#十六进制转换程序" class="headerlink" title="十六进制转换程序"></a>十六进制转换程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomhu.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatTest5</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> b: data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n %<span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                builder.append(String.format(<span class="string">"%05x: "</span>, n));</span><br><span class="line">            &#125;</span><br><span class="line">            builder.append(String.format(<span class="string">"%02x "</span>, b));</span><br><span class="line">            n ++;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                builder.append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = <span class="string">"my name is huhx, welcome to my blog"</span>;</span><br><span class="line">        System.out.println(format(string.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">00000</span>: <span class="number">6</span>d <span class="number">79</span> <span class="number">20</span> <span class="number">6</span>e <span class="number">61</span> <span class="number">6</span>d <span class="number">65</span> <span class="number">20</span> <span class="number">69</span> <span class="number">73</span> <span class="number">20</span> <span class="number">68</span> <span class="number">75</span> <span class="number">68</span> <span class="number">78</span> <span class="number">2</span>c </span><br><span class="line"><span class="number">00010</span>: <span class="number">20</span> <span class="number">77</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">63</span> <span class="number">6f</span> <span class="number">6</span>d <span class="number">65</span> <span class="number">20</span> <span class="number">74</span> <span class="number">6f</span> <span class="number">20</span> <span class="number">6</span>d <span class="number">79</span> <span class="number">20</span> <span class="number">62</span> </span><br><span class="line"><span class="number">00020</span>: <span class="number">6</span>c <span class="number">6f</span> <span class="number">67</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p>**<br>length方法返回当前字符串的长度<br>可以有长度为0的字符串,即空字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name =<span class="string">"盖伦"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(name.length());</span><br><span class="line"></span><br><span class="line">        String unknowHero = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以有长度为0的字符串,即空字符串</span></span><br><span class="line">        System.out.println(unknowHero.length());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java语法</category>
      </categories>
      <tags>
        <tag>java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA How2J</title>
    <url>/2020/02/28/JAVA%20How2J/</url>
    <content><![CDATA[<h1 id="How2J"><a href="#How2J" class="headerlink" title="How2J"></a>How2J</h1><h2 id="JAVA中的类和对象"><a href="#JAVA中的类和对象" class="headerlink" title="JAVA中的类和对象"></a>JAVA中的类和对象</h2><ul>
<li>在编程时，类Hero的概念是<strong>一些共同的状态，针对不同的英雄进行不同的对象的实例化，所以实际应用中编程思路要清晰！类就像一个模板</strong>，根据这样一个模板，可以创建一个个的具体的英雄；一个个具体的英雄，就叫一个个的<strong>对象 ，new Hero()</strong> 就是java中创建一个英雄对象的意；</li>
</ul>
<p>Error:(47, 36) java: 未结束的字符文字<br>错误原因：编码方式的不同，修改之后发现是字符型需要双引号而不是单引号！</p>
<p>Non-static field ‘gailun’ cannot be referenced from a static context<br>是main主函数中，由于主函数是静态函数，所以我们如果在main函数外面实例化，但是不指定对象为静态对象，那么该对象将找不到，或者我们把类设为静态类</p>
<a id="more"></a>
<h1 id="错误："><a href="#错误：" class="headerlink" title="错误："></a>错误：</h1><h2 id="1-静态方法里面不能出现this、super"><a href="#1-静态方法里面不能出现this、super" class="headerlink" title="1.静态方法里面不能出现this、super"></a>1.静态方法里面不能出现this、super</h2><p>原因：<br>  这个要从java的内存机制去分析，首先当你New 一个对象的时候，并不是先在堆中为对象开辟内存空间，而是先将类中的静态方法（带有static修饰的静态函数）的代码加载到一个叫做方法区的地方，然后再在堆内存中创建对象。所以说静态方法会随着类的加载而被加载。当你new一个对象时，该对象存在于对内存中，this关键字一般指该对象，但是如果没有new对象，而是通过类名调用该类的静态方法也可以。<br>程序最终都是在内存中执行，变量只有在内存中占有一席之地时才会被访问，类的静态成员（静态变量和静态方法）属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问，非静态成员（非静态变量和非静态方法）属于类的对象，所以只有在类的对象创建（实例化）的时候才会分配内存，然后通过类的对象去访问。<br>在一个类的静态成员中去访问非静态成员之所以会出错是因为在类的非静态成员不存在的时候静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。</p>
<p><em>在《Java编程思想》P86页有这样一段话：</em><br>_　　“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”_<br>_　　这段话虽然只是说明了static方法的特殊之处，但是可以看出static关键字的基本作用，简而言之，一句话来描述就是：_<br>_　　方便在没有创建对象的情况下来进行调用（方法/变量）。_<br>_　　很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。_<br>　　<strong>static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。</strong><br><strong>1）static方法</strong><br>　　static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。<br>　　但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。举个简单的例子：</p>
<p>　　在上面的代码中，由于print2方法是独立于对象存在的，可以直接用过类名调用。假如说可以在静态方法中访问非静态方法/变量的话，那么如果在main方法中有下面一条语句：<br>　　MyObject.print2();<br>　　此时对象都没有，str2根本就不存在，所以就会产生矛盾了。同样对于方法也是一样，由于你无法预知在print1方法中是否访问了非静态成员变量，所以也禁止在静态成员方法中访问非静态成员方法。<br>　　而对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的。<br>　　因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。<br>　　另外记住，即使没有显示地声明为static，类的构造器实际上也是静态方法。<br><strong>2）static变量</strong><br>　　static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。<br>　　static成员变量的初始化顺序按照定义的顺序进行初始化。<br><strong>3）static代码块</strong><br>　　static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。<br>　　为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。</p>
<h2 id="2-静态变量不能出现在方法里面"><a href="#2-静态变量不能出现在方法里面" class="headerlink" title="2. 静态变量不能出现在方法里面"></a>2. 静态变量不能出现在方法里面</h2><p>  无论是静态方法还是普通方法都不行，因为静态这个概念是主要针对类级别的，方法里面的变量是局部变量。方法区里面放的是和堆一样，被所有的线程共享，方法区中包含所有的class和static变量，方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。<br>？<br>不能定义，但是可以使用，具体规则见<a href="https://blog.csdn.net/doit_kang/article/details/83376985" target="_blank" rel="noopener">https://blog.csdn.net/doit_kang/article/details/83376985</a></p>
<h2 id="3-构造方法不能用static静态来修饰"><a href="#3-构造方法不能用static静态来修饰" class="headerlink" title="3.构造方法不能用static静态来修饰"></a>3.构造方法不能用static静态来修饰</h2><p>  构造方法不能用static静态来修饰。<a href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95&from=1012015a&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLPH9WPyfLP1Tkrjw9rAFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnWcvrHbkrjDLrHb3Pjb4njnsr0" target="_blank" rel="noopener">静态方法</a>可以在未创建对象时调用，从这个角度看，<a href="https://www.baidu.com/s?wd=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&from=1012015a&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLPH9WPyfLP1Tkrjw9rAFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnWcvrHbkrjDLrHb3Pjb4njnsr0" target="_blank" rel="noopener">构造方法</a>在对象未创建时调用，可以看作是<a href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95&from=1012015a&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLPH9WPyfLP1Tkrjw9rAFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnWcvrHbkrjDLrHb3Pjb4njnsr0" target="_blank" rel="noopener">静态方法</a>。但从另一个方面来看，<a href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95&from=1012015a&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLPH9WPyfLP1Tkrjw9rAFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnWcvrHbkrjDLrHb3Pjb4njnsr0" target="_blank" rel="noopener">静态方法</a>不能调用实例方法（无关键字静态的类方法），而<a href="https://www.baidu.com/s?wd=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&from=1012015a&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLPH9WPyfLP1Tkrjw9rAFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnWcvrHbkrjDLrHb3Pjb4njnsr0" target="_blank" rel="noopener">构造方法</a>可以调用实例方法，所以<a href="https://www.baidu.com/s?wd=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&from=1012015a&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLPH9WPyfLP1Tkrjw9rAFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnWcvrHbkrjDLrHb3Pjb4njnsr0" target="_blank" rel="noopener">构造方法</a>也不算是静态方法。</p>
<p>在一个类中访问同一个类的变量：！！！！！！</p>
<p>首先明白只能访问成员变量，因为局部变量作用域只是在方法内，我们可以让方法里面的局部变量对成员变量进行修改即可（同名，且方法里面的变量不需要指定类型，代表覆盖之前的变量）</p>
<p>局部变量可以和成员变量重名，不加“this”修饰时，优先使用最近的变量。<br>实际中常常给变量定义一些getXXX{returnXXX}的方法来进行调用参数</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1577085428435-16df2316-c09f-4d67-9d73-01d0d581d06a.png#align=left&display=inline&height=288&name=image.png&originHeight=362&originWidth=594&size=22557&status=done&style=none&width=472" alt="image.png"></p>
<ul>
<li>char类型用于存放一个字符，值用单引号’表示 (双引号表示字符串)，其长度和short一样，也是16位的，<strong>只能存放一个字符</strong>，超过一个字符就会产生编译错误</li>
<li>浮点数类型有两种</li>
</ul>
<p><em>float 长度为32位</em><br><em>double 长度为64位</em><br><em><strong>注意： 默认的小数值是double类型的</strong></em><br><em>所以 float f = 54.321会出现编译错误，因为54.321的默认类型是 double，其类型 长度为64，超过了float的长度32</em><br><em>在数字后面<strong>加一个字母f</strong>，直接把该数字声明成float类型</em><br><em>float f2 = 54.321<strong>f</strong>,，这样就不会出错了</em><br><em><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1577085958923-8c823552-cd30-490b-b91a-a385c774f3ae.png#align=left&display=inline&height=249&name=image.png&originHeight=275&originWidth=614&size=16825&status=done&style=none&width=556" alt="image.png"></em><br>_</p>
<ul>
<li>布尔型用于表示真假</li>
</ul>
<p>其长度为1<br><em>boolean b1 = true;</em><br><em>boolean b2 = false;</em><br><em>分别代表真假</em></p>
<p><em>虽然布尔型真正存放的数据是0(false) 1(true)</em><br><em>但是，不能直接使用0 1 进行赋值</em><br><em><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1577086020566-3d4348e9-0f23-4e20-9068-e438385f932c.png#align=left&display=inline&height=179&name=image.png&originHeight=179&originWidth=615&size=10209&status=done&style=none&width=615" alt="image.png"></em></p>
<ul>
<li>String类型其实<strong>并不是基本类型</strong>，但是它是如此广泛的被使用，常常被误以为是一种基本类型。</li>
</ul>
<p>String类型是Immutable的，一旦创建就不能够被改变，更多的关于String的学习，<a href="https://www.yuque.com/aichifandehuahua/tqy8d0/pynxda" target="_blank" rel="noopener">String详解</a></p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><p><a href="https://how2j.cn/k/variable/variable-transfer/264.html" target="_blank" rel="noopener">https://how2j.cn/k/variable/variable-transfer/264.html</a><br>转换规则如图所示</p>
<p><strong>精度高</strong>的数据类型就像<strong>容量大</strong>的杯子，可以<strong>放更大</strong>的数据<br><strong>精度低</strong>的数据类型就像<strong>容量小</strong>的杯子，只能<strong>放更小</strong>的数据<br>小杯子往大杯子里倒东西，大杯子<strong>怎么都放得下</strong><br>大杯子往小杯子里倒东西，<strong>有的时候放的下</strong>，<strong>有的时候就会有溢出</strong><br>需要注意的一点是<br>虽然short和char都是16位的，长度是一样的<br>但是彼此之间，依然需要进行强制转换<br><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1577093853502-ab73cd05-819b-4e4f-ad55-b63100707a9c.png#align=left&display=inline&height=306&originHeight=453&originWidth=639&size=0&status=done&style=none&width=432" alt><br>代码比较复制代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">		<span class="keyword">short</span> s = <span class="number">80</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//虽然short和char都是16位的，长度是一样的</span></span><br><span class="line">		<span class="comment">//但是彼此之间，依然需要进行强制转换</span></span><br><span class="line">		c = (<span class="keyword">char</span>) s;</span><br><span class="line">		<span class="comment">//直接进行转换，会出现编译错误</span></span><br><span class="line">		s = c;<span class="comment">//报错</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提示错误s=c的地方报错</span></span><br><span class="line">Error:(<span class="number">12</span>, <span class="number">13</span>) java: 不兼容的类型: 从<span class="keyword">char</span>转换到<span class="keyword">short</span>可能会有损失</span><br></pre></td></tr></table></figure>

<h4 id="低精度向高精度转换"><a href="#低精度向高精度转换" class="headerlink" title="低精度向高精度转换**"></a>低精度向高精度转换**</h4><p>long l = 50;<br>int i = 50;</p>
<p>l 是long类型的，其类型长度是64位<br>i 是int类型的，其类型长度是32位<br>所以l的精度，比i的精度要高<br>l = i;<br><strong>把i的值赋给l</strong>， 首先l和i彼此的类型是不一样的，那么能否转换就取决于彼此的精度<br>这个例子，是低精度向高精度转换 是可以正常转换的<br>换句话说，int比较小，要放进比较大的long,随便怎么样，都放的进去<img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1577093853476-1bbb2e12-05b1-4da4-9dcf-d3a975cc767c.png#align=left&display=inline&height=205&originHeight=220&originWidth=661&size=0&status=done&style=none&width=617" alt><br>代码比较复制代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">50</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//int比较小，要放进比较大的long,随便怎么样，都放的进去</span></span><br><span class="line">        l = i;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正常</span></span><br></pre></td></tr></table></figure>

<h4 id="高精度向低精度转换"><a href="#高精度向低精度转换" class="headerlink" title="高精度向低精度转换**"></a>高精度向低精度转换**</h4><p>byte b = 5;<br>int i1 = 10;<br>int i2 = 300;<br>b = i1;<br>b=i2;<br>b的类型是byte,其长度是8，<strong>最大只能放127</strong><br>i1 的类型是int, 其长度是32,最大，反正就是很大了，超过127<br>所以， 把int类型的数据转成为byte类型的数据，<strong>是有风险的</strong><br><strong>有的时候是可以转换的</strong>，比如 b = i1 (i1=10);<br><strong>有的时候不可以转换</strong> 比如 b= i2 (i2=300) 因为放不下了<br>编译器就会提示错误<br>这个时候就只能采用<strong>强制转换</strong>，强制转换的意思就是，转是可以转的，但是不对转换之后的值负责。 风险自担，后果自负<img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1577093853455-60eb0c52-4abc-4d56-afd7-2a40af9060c9.png#align=left&display=inline&height=318&originHeight=339&originWidth=635&size=0&status=done&style=none&width=596" alt><br>代码比较复制代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">300</span>;</span><br><span class="line">         </span><br><span class="line">        b = (<span class="keyword">byte</span>) i1;</span><br><span class="line">        <span class="comment">//因为i1的值是在byte范围之内，所以即便进行强制转换</span></span><br><span class="line">        <span class="comment">//最后得到的值，也是10</span></span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//因为i2的值是在byte范围之外，所以就会按照byte的长度进行截取</span></span><br><span class="line">        <span class="comment">//i2的值是300，其对应的二进制数是 100101100</span></span><br><span class="line">        <span class="comment">//按照byte的长度8位进行截取后，其值为 00101100 即44</span></span><br><span class="line">        b =(<span class="keyword">byte</span>) i2;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查看一个整数对应的二进制的方法：</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(i2));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><ul>
<li>标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含 @、%、空格等其它特殊字符，不能以数字开头。譬如：123name 就是不合法滴</li>
<li>标识符不能是 Java 关键字和保留字（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Myvoid 可以</li>
<li>标识符是严格区分大小写的。 所以涅，一定要分清楚 imooc 和 IMooc 是两个不同的标识符哦！</li>
<li>标识符的命名最好能反映出其作用，做到见名知意</li>
<li>变量命名只能使用<strong>字母 数字 $ _，</strong>变量第一个字符 只能使用 字母 、$、 <em>，变量第一个字符 不能使用数字。注：</em> 是下划线，不是-减号或者—— 破折号</li>
<li>在命名的时候，尽量使用完整的单词进行命名，比如name,moveSpeed，而不是使用缩写 n,m。</li>
<li>不能只使用关键字，但是可以包含关键字</li>
<li>@、*、”、#都不属于可用符号</li>
<li>中文也是可以用来命名变量的，但是在实际工作中尽量<strong>别这么干！</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1577083519786-0d10936d-cfaa-45d7-a03b-19fc2bbd0a31.png#align=left&display=inline&height=225&name=image.png&originHeight=321&originWidth=423&size=16702&status=done&style=none&width=296" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/539392/1577083577319-bce00875-4449-4442-b954-ebec6e761989.png#align=left&display=inline&height=258&name=image.png&originHeight=366&originWidth=450&size=20614&status=done&style=none&width=317" alt="image.png"></p>
<h4 id="方法的参数"><a href="#方法的参数" class="headerlink" title="方法的参数"></a>方法的参数</h4><h3 id="Java的格式化输出"><a href="#Java的格式化输出" class="headerlink" title="Java的格式化输出"></a><a href="https://www.cnblogs.com/qunqun/p/8656217.html" target="_blank" rel="noopener">Java的格式化输出</a></h3>]]></content>
      <categories>
        <category>java语法</category>
      </categories>
      <tags>
        <tag>java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>编译及初始化过程（类初始化 对象初始化）</title>
    <url>/2020/02/28/JAVA%20%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%20%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89/</url>
    <content><![CDATA[<h1 id="编译及初始化过程（类初始化-对象初始化）"><a href="#编译及初始化过程（类初始化-对象初始化）" class="headerlink" title="编译及初始化过程（类初始化 对象初始化）"></a>编译及初始化过程（类初始化 对象初始化）</h1><p><a href="https://www.runoob.com/w3cnote/java-init-object-process.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/java-init-object-process.html</a></p>
<h2 id="一个类及其对象初始化的过程"><a href="#一个类及其对象初始化的过程" class="headerlink" title="一个类及其对象初始化的过程"></a>一个类及其对象初始化的过程</h2><h3 id="一、什么时候需要初始化一个类"><a href="#一、什么时候需要初始化一个类" class="headerlink" title="一、什么时候需要初始化一个类"></a>一、什么时候需要初始化一个类</h3><p>首次创建某个对象时:<br>Dog dog = new Dog();<br>首次访问某个类的静态方法或者静态字段时:<br>Dog.staticFields;<br>Java 解释器就会去找类的路径，定位已经编译好的 Dog.class 文件。</p>
<h3 id="二、获得类的资源"><a href="#二、获得类的资源" class="headerlink" title="二、获得类的资源"></a>二、获得类的资源</h3><p>然后 jvm 就会载入 Dog.class，生成一个 class 对象。这个时候如果有静态的方法或者变量，静态初始化动作都会被执行。这个时候要注意啦，静态初始化在程序运行过程中只会在 Class 对象首次加载的时候运行一次。这些资源都会放在 jvm 的方法区。<br>方法区又叫静态区，跟堆一样，被所有的线程共享。<br>方法区中包含的都是在整个程序中永远唯一的元素，包含所有的 class 和 static 变量。</p>
<h3 id="三、初始化对象-Dog-dog-new-Dog"><a href="#三、初始化对象-Dog-dog-new-Dog" class="headerlink" title="三、初始化对象 Dog dog = new Dog()"></a>三、初始化对象 <strong>Dog dog = new Dog()</strong></h3><ul>
<li><p>1.第一次创建 Dog 对象先执行上面的一二步</p>
</li>
<li><p>2.在堆上为 Dog 对象分配足够的存储空间，所有属性和方法都被设置成默认值(数字为 0，字符为 null，布尔为 false，而所有引用被设置成 null）</p>
</li>
<li><p>3.执行构造函数检查是否有父类，如果有父类会先调用父类的构造函数，这里假设 Dog 没有父类，执行默认值字段的赋值即方法的初始化动作。</p>
</li>
<li><p>4.执行构造函数。</p>
<a id="more"></a>

</li>
</ul>
<hr>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="-2"><a href="#-2" class="headerlink" title></a></h2><h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><h3 id="什么时候需要初始化一个类"><a href="#什么时候需要初始化一个类" class="headerlink" title="什么时候需要初始化一个类"></a>什么时候需要初始化一个类</h3><p>首次创建某个对象时:</p>
<ul>
<li>Dog dog = new Dog(); </li>
</ul>
<p>首次访问某个类的静态方法或者静态字段时:</p>
<ul>
<li>Dog.staticFields;<h2 id="-3"><a href="#-3" class="headerlink" title></a></h2></li>
</ul>
<hr>
<h2 id="-4"><a href="#-4" class="headerlink" title></a></h2><h2 id="-5"><a href="#-5" class="headerlink" title></a></h2><h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p><strong>为什么对属性和方法初始化之后再执行构造函数其他的部分？</strong><br>因为构造函数中的显式部分有可能使用到对象的属性和方法。<br>Tips：其实这种初始化过程都是为了保证后面资源初始化用到的东西前面的已经初始化完毕了。</p>
<p>  在Java程序中，我们是<strong>可以在构造方法中调用本类的方法和成员变量</strong>的，但是要注意一点，当我们需要调用一个非static的方法时，该方法不应该可以被子类覆盖，应该用final修饰或将其变成private，这虽然语法上没有具体要求，但是若不遵守这个约定，会导致异常情况发生。</p>
<hr>
]]></content>
      <categories>
        <category>java语法</category>
      </categories>
      <tags>
        <tag>java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离 服务器端概念理解</title>
    <url>/2020/02/28/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前后端分离-服务器端概念理解"><a href="#前后端分离-服务器端概念理解" class="headerlink" title="前后端分离 服务器端概念理解"></a>前后端分离 服务器端概念理解</h1><p><strong>前端后端有两种协作方式，一种可以称之为是服务器端渲染，一种是叫做前后端分离。</strong><br>这两种方式的差别是什么呢？</p>
<p>服务器端渲染的方式，是指在服务器端就将网页直接生成，浏览器这里拿到的是一整个网页，CSS和JS的部分是在浏览器端执行的，而网页的内容部分，也就是数据，是由服务器端生成的。<br>这叫做服务器端渲染。</p>
<p>至于你是用NodeJS，还是用PHP，还是Python，还是Java，还是NodeJS+Java,都不重要。<br>这是我一直都觉得，很多概念在混淆的原因，很多人都觉得说到前后端分离，就是JS和Java的分离，只要我用了JS，Java提供API，就是前后端分离了。</p>
<p>是这样么？不是的。<br>只要你的Html网页的内容是在服务器端生成的，这就是服务器端渲染的方式。你用Openresty+lua没问题。<br>只要你的网页是在浏览器端，内容是通过接口从后端拿到的纯数据，这就是前后端分离。</p>
<p>第二种方式就是，前后端分离的方式，也是刚刚说到的。浏览器端先拿到Html，然后和后端通过Ajax接口获取，或者是通过其他接口获取，无所谓。</p>
<p>所以两种方式的区别关键，就在于是，Html是在哪儿生成的，浏览器和服务端传递的是什么。<br>在前后端分离的方式，浏览器和服务端传递的是数据，而在服务器端渲染的过程中，传递的是Html网页。</p>
<p>弄清楚这两点的差别，再来看两种方式的好坏。<br>1 数据量：前后端分离中传递数据，所以传输量会小。<br>服务器端渲染，会传输更大的数据，而且，会有很多内容是重复的。<br>2 体验：前后端多了一个渲染数据的过程，服务器端省去了这个过程。这也是一直被提到的首屏渲染的问题。<br> <a id="more"></a><br>3 解耦：前后端分离中，传输的是数据，Model，数据怎么展示，全部交给前端来处理，后端只负责提供数据。<br>服务器端渲染中，传输的是Html，后端传给前端的Model，通常是通过Hidden的Input来处理，或者是直接用模板技术生成（JSP，Velocity，freemak）等。<br>数据和展现并未分离，在过去，这被称之为套页面。<br>4 控制：网页之间有各种跳转交互，在前后端分离中，跳转的页面控制，全部是由前端来决定。跟后端完全没有关系。在服务器端渲染的方式中，大部分是由后端来决定，少部分是由前端来决定。</p>
<p>5 SEO：前后端分离的方式，通常的载体是SPA，所以拿到的是没有数据的空壳子，很多搜索引擎，不支持SPA方式的SEO。<br>而服务器端渲染的方式，因为生成的是网页，所以对SEO支持的很好。</p>
<p>不要小巧这个环节，这是重多前台网站放弃使用前后端分离方式的重要原因。</p>
<p>好了，以上5点，足以让你对前后端分离和服务器渲染两种方式有一些直观的认知了。</p>
<p>再举个例子：<br>盒马生鲜提供两种方式，一种是前后端分离，一种是服务器端渲染。<br>前后端分离是哪种方式呢？就是外卖或者是直接买生鲜，自己回家去做。<br>服务器端渲染是哪种方式呢？就是直接在盒马鲜生自己加工，直接吃，或者是带回家吃。</p>
<p>这里的生鲜就是数据。<br>做出来的食物就是Html网页。</p>
<p>接着看在什么样的场景下，应该使用前后端分离，很简单。<br>“不需要SEO的场景下，都应该使用前后端分离”。</p>
<p>所以在后台管理中，没有任何理由不使用前后端分离，代指SPA。<br>而在前台页面中，要认真考虑，不支持SEO的代价，不止几百万。<br>前后需要用户登录的页面，往往是不需要有SEO的，这里也可以拆解出来。</p>
<p>再说一下，什么是动静分离。<br>之前跟人讨论的时候，有人说你不懂什么叫前后端分离，就算是服务器端渲染，也可以把CSS和JS从Java代码中剥离出来。</p>
<p>可是这更应该叫做动静分离，跟前后端分离是完全两个含义。<br>动静分离主要在于部署，静态代码部署不用重启，动态代码部署需要重启，很多时候我改一个样式，不想要重启服务，不想要重新打Tag。</p>
<p>所以，说到前后端分离，前后端只传递数据的方式，是彻底的改变，不是什么后端前端撕逼（所有管理能解决的问题都不是技术问题），也不是什么后端不想要给前后提供数据，就是单纯的这种方式更符合前后端交互的逻辑，后端本来就只应该关心数据，和Android和IOS的交互方式一样，根本不用关心数据怎么展示。</p>
<p>前端说到的前后端分离，在某种程度上，就是和Android和IOS看齐。</p>
<p>关键点弄明白了，其他的各种好处我可以随便扯了，比如说后端提供一套API，比如说，前端部署更方便，双方开发速度更快更高效，更适合做单元测试等等等。<br>而题主说到的后台没有拆分，很可能的原因就是“懒”。</p>
<p>很多时候，我知道怎么样做是对的，但是我就是懒，这是程序员的天性，特别是在一个人开发的时候。</p>
]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java开发</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-基本包装类型和引用类型概念区分</title>
    <url>/2020/02/28/JavaScript-%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/</url>
    <content><![CDATA[<h1 id="JavaScript-基本包装类型和引用类型概念区分"><a href="#JavaScript-基本包装类型和引用类型概念区分" class="headerlink" title="JavaScript-基本包装类型和引用类型概念区分"></a>JavaScript-基本包装类型和引用类型概念区分</h1><p><a href="https://blog.csdn.net/qq_41218152/article/details/81976148" target="_blank" rel="noopener">https://blog.csdn.net/qq_41218152/article/details/81976148</a></p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li>
<li>对象、数组都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用任何与之兼容的类型。</li>
<li>例子：Site site = new Site(“Runoob”)。</li>
</ul>
<h3 id="Java的引用类型"><a href="#Java的引用类型" class="headerlink" title="Java的引用类型"></a>Java的引用类型</h3><h4 id="概念1"><a href="#概念1" class="headerlink" title="概念1."></a>概念1.</h4><p>引用类型（包装器类型）是一个对象类型，值是什么呢？它的值是指向内存空间的引用，就是地址，所指向的内存中保存着变量所表示的一个值或一组值。<br>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。<br>引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。<br>对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。同时为了面向对象操作的一致性。<br>这些基本类型都有相应的封装类型：Integer、Short、Long、Byte、Float、Double、Character等。</p>
<h4 id="概念2"><a href="#概念2" class="headerlink" title="概念2."></a>概念2.</h4><p>Java的4种引用类型：<br>他们分别是其引用(StrongReference)，软引用(SoftReference)，弱引用(WeakReference)以及PhantomReference(虚引用)，他们被GC回收的可能性从大到小排列。<br><a href="https://blog.csdn.net/qq_27639777/article/details/90143738" target="_blank" rel="noopener">https://blog.csdn.net/qq_27639777/article/details/90143738</a></p>
 <a id="more"></a>

<h1 id="基本包装类型和引用类型"><a href="#基本包装类型和引用类型" class="headerlink" title="基本包装类型和引用类型"></a>基本包装类型和引用类型</h1><h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>为了便于操作基本类型值，JavaScript提供了三个特殊的引用类型：Boolean、Number和String。这些类型与其他引用类型相似，但同时也具有与各自基本类型相应的特殊行为<br>实际上，每当读取一个基本类型值的时候，后太就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法操作这些数据</p>
<h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1=<span class="string">"some text"</span>;</span><br><span class="line"><span class="keyword">var</span> s2=s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>//变量s1包含一个字符串，字符串是基本类型值。下一行调用了s1的substring()方法，并将返回结果保存到了s2中<br>//基本类型值不是对象，因此逻辑上不应该有方法。其实，为了实现这种直观的操作，后台已经自动完成了一系列的处理。<br>//当第二行代码访问s1时，访问过称出于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理<br>/*<br>(1)创建String类型的一个实例<br>(2)在实例上调用指定的方法<br>(3)销毁这个实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1=<span class="keyword">new</span> String(<span class="string">"some text"</span>);</span><br><span class="line"><span class="keyword">var</span> s2=s1.substring(<span class="number">2</span>);</span><br><span class="line">s1=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>//经过这些处理，基本的字符串值就变得和对象一样了。而且，上面的三个步骤也适用Boolean和Number类型对应的布尔值和数字值<br>*/</p>
<h3 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h3><h4 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1.相关概念"></a>1.相关概念</h4><p>引用类型与基本包装类型的主要区别就是对象的生存期<br>使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中<br>自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁</p>
<h4 id="2-实例-1"><a href="#2-实例-1" class="headerlink" title="2.实例"></a>2.实例</h4><p>//这就意味着不能在运行时为基本类型值添加属性和方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1=<span class="string">"some text"</span>;</span><br><span class="line">s1.color=<span class="string">"red"</span>;</span><br><span class="line">alert(s1.color);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>//在此，第二行代码试图为字符串s1添加一个color属性。但是，当第三行代码在此访问s1时，其color属性没有了。就是因为第二行常见的String对象在执行第三行代码时已经被销毁了。第三行又创建自己的String对象，而该对象没有color属性</p>
<h2 id="三、显示创建基本包装类型"><a href="#三、显示创建基本包装类型" class="headerlink" title="三、显示创建基本包装类型"></a>三、显示创建基本包装类型</h2><p>1.相关概念<br>可以显示地调用Boolean、Number和String来创建基本包装类型的对象<br>应该在绝对必要的情况下在再这样做，因为这样会让人分不清自己是在处理基本类型还是引用类型的值<br>对基本包装类型的实例调用typeof会返回”Object”,而所有基本包装类型的对象在转换为布尔值是值都是true<br>2.Object()<br>Object构造函数会将根据传入值的类型返回相应基本包装类型的实例<br>把字符串传给Object构造函数，就会创建String的实例；而传入的数值参数会得到Number的实例；传入布尔值就会得到Boolean的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Object(<span class="string">"some text"</span>);</span><br><span class="line">alert(obj <span class="keyword">instanceof</span> String);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>3.使用new调用基本包装类型的构造函数<br>使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的<br>虽然不建议显示地创建基本包装类型的对象，但它们操作基本类型值的能力还是很重要的。而每个基本包装类型都提供了操作相应值的便捷方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value=<span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> number=Number(value);<span class="comment">//"转型函数"</span></span><br><span class="line">alert(typeof number);<span class="comment">//"number"</span></span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Number(value);<span class="comment">//构造函数</span></span><br><span class="line">alert(typeof obj);<span class="comment">//"object"</span></span><br><span class="line"><span class="comment">//变量number中保存的是基本类型的值25，而变量obj中保存的的事Number的实例</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java语法</category>
      </categories>
      <tags>
        <tag>java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>变量 类 方法 代码块 格式总结</title>
    <url>/2020/02/28/JAVA%E5%8F%98%E9%87%8F%20%E7%B1%BB%20%E6%96%B9%E6%B3%95%20%E4%BB%A3%E7%A0%81%E5%9D%97%20%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="变量-类-方法-代码块-格式总结"><a href="#变量-类-方法-代码块-格式总结" class="headerlink" title="变量 类 方法 代码块 格式总结"></a>变量 类 方法 代码块 格式总结</h1><h2 id="变量-类-方法-代码块-格式总结-1"><a href="#变量-类-方法-代码块-格式总结-1" class="headerlink" title="变量 类 方法 代码块 格式总结"></a>变量 类 方法 代码块 格式总结</h2><h2 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h2><p>常量在程序运行时是不能被修改的。<br>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：<br>final double PI = 3.1415927;<br>虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。<br>字面量可以赋给任何内置类型的变量。例如：<br>byte a = 68;<br>char a = ‘A’<br>byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。<br>当使用常量的时候，前缀 <strong>0</strong> 表示 8 进制，而前缀 <strong>0x</strong> 代表 16 进制, 例如：<br>int decimal = 100;<br>int octal = 0144;<br>int hexa =  0x64;<br>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：<br>“Hello World”<br>“two\nlines”<br>“&quot;This is in quotes&quot;“<br>字符串常量和字符常量都可以包含任何Unicode字符。例如：<br>char a = ‘\u0001’;<br>String a = “\u0001”;<br>Java语言支持一些特殊的转义字符序列。</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">字符含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\n</td>
<td align="left">换行 (0x0a)</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车 (0x0d)</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符(0x0c)</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格 (0x08)</td>
</tr>
<tr>
<td align="left">\0</td>
<td align="left">空字符 (0x20)</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">字符串</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表符</td>
</tr>
<tr>
<td align="left">\“</td>
<td align="left">双引号</td>
</tr>
<tr>
<td align="left">\‘</td>
<td align="left">单引号</td>
</tr>
<tr>
<td align="left">\\</td>
<td align="left">反斜杠</td>
</tr>
<tr>
<td align="left">\ddd</td>
<td align="left">八进制字符 (ddd)</td>
</tr>
<tr>
<td align="left">\uxxxx</td>
<td align="left">16进制Unicode字符 (xxxx)</td>
</tr>
</tbody></table>
<hr>
 <a id="more"></a>
<h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong><br>转换从低级到高级。<br>低  ————————————&gt;  高</p>
<p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double<br>数据类型转换必须满足如下规则：</p>
<ul>
<li><ol>
<li>不能对boolean类型进行类型转换。</li>
</ol>
</li>
<li><ol start="2">
<li>不能把对象类型转换成不相关类的对象。</li>
</ol>
</li>
<li><ol start="3">
<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
</ol>
</li>
<li><ol start="4">
<li>转换过程中可能导致溢出或损失精度，例如：</li>
</ol>
</li>
</ul>
<p>int i =128;<br>byte b = (byte)i;</p>
<ul>
<li>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</li>
<li><ol start="5">
<li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</li>
</ol>
</li>
</ul>
<p>(int)23.7 == 23;<br>(int)-45.89f == -45</p>
<h3 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>public class ZiDongLeiZhuan{<br>        public static void main(String[] args){<br>            char c1=’a’;//定义一个char类型<br>            int i1 = c1;//char自动类型转换为int<br>            System.out.println(“char自动类型转换为int后的值等于”+i1);<br>            char c2 = ‘A’;//定义一个char类型<br>            int i2 = c2+1;//char 类型和 int 类型计算<br>            System.out.println(“char类型和int计算后的值等于”+i2);<br>        }<br>}<br>运行结果为:<br>char自动类型转换为int后的值等于97<br>char类型和int计算后的值等于66<br><strong>解析：</strong>c1 的值为字符 <strong>a</strong> ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 <strong>i2=65+1=66</strong>。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul>
<li><ol>
<li>条件是转换的数据类型必须是兼容的。</li>
</ol>
</li>
<li><ol start="2">
<li>格式：(type)value type是要强制类型转换后的数据类型 实例：<br>实例<br>public class QiangZhiZhuanHuan{<br> public static void main(String[] args){<br>   int i1 = 123;<br>   byte b = (byte)i1;//强制类型转换为byte<br>   System.out.println(“int强制类型转换为byte后的值等于”+b);<br> }<br>}<br>运行结果：</li>
</ol>
</li>
</ul>
<p>int强制类型转换为byte后的值等于123</p>
<h3 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h3><ul>
<li><ol>
<li>整数的默认类型是 int。</li>
</ol>
</li>
<li><ol start="2">
<li>浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="java三大体系"><a href="#java三大体系" class="headerlink" title="java三大体系"></a>java三大体系</h2><p>Java SE (Java Platfor Standard Edition)</p>
<p>标准版：它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用Java程序。Java SE包含支持Java Web服务开发的类，并为Java EE提供基础。</p>
<p>Java EE (Java platfor Enterorise Edition)</p>
<p>企业版：帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java应用程序。Java EE是在Java SE的基础上构建的，它提供Web服务、组件模型管理和通信API，可以用来实现企业级的面向面向服务体系结构和Web2.0应用程序。</p>
<p>Java ME (Java platfor Micro Edition)</p>
<p>微型版：Java ME在为移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供了一个健壮而灵活地环境。</p>
<hr>
<h2 id="内部类（嵌套）"><a href="#内部类（嵌套）" class="headerlink" title="内部类（嵌套）"></a>内部类（嵌套）</h2><p>提示错误：Error:(25, 17) java: 无法从静态上下文中引用非静态 变量 this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error:(<span class="number">25</span>, <span class="number">17</span>) java: 无法从静态上下文中引用非静态 变量 <span class="keyword">this</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java语法</category>
      </categories>
      <tags>
        <tag>java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器详解</title>
    <url>/2020/02/28/Java%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java容器详解"><a href="#Java容器详解" class="headerlink" title="Java容器详解"></a>Java容器详解</h1><h1 id><a href="#" class="headerlink" title></a><img src="https://upload-images.jianshu.io/upload_images/8629618-ef95bdd28ee20f56.gif#align=left&display=inline&height=611&originHeight=611&originWidth=643&status=uploading&style=none&width=643" alt></h1><h1 id="-1"><a href="#-1" class="headerlink" title></a></h1><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><blockquote>
<p>有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。<br>与 set 不同，列表通常允许重复的元素。更确切地讲，列表通常允许满足 <code>e1.equals(e2)</code> 的元素对 e1 和 e2，并且如果列表本身允许 null 元素的话，通常它们允许多个 null 元素。难免有人希望通过在用户尝试插入重复元素时抛出运行时异常的方法来禁止重复的列表，但我们希望这种用法越少越好。</p>
</blockquote>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList<E></E></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>List 接口的大小可变数组的实现</strong>。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的。）<br><code>size</code>、<code>isEmpty</code>、<code>get</code>、<code>set</code>、<code>iterator</code> 和 <code>listIterator</code> 操作都以固定时间运行。add 操作以分摊的固定时间 运行，也就是说，<strong>添加 n 个元素需要 O(n) 时间</strong>。其他所有操作都以线性时间运行（大体上讲）。<em>与用于 LinkedList 实现的常数因子相比，此实现的常数因子较低_。<br>每个 ArrayList 实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。并未指定增长策略的细节，因为这不只是添加元素会带来分摊固定时间开销那样简单。<br>_在添加大量元素前，应用程序可以使用 <code>ensureCapacity</code> 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</em><br>注意，<strong>此实现不是同步的</strong>。如果多个线程同时访问一个 ArrayList 实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。</p>
</blockquote>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList<E></E></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>List 接口的链接列表实现</strong>。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 <code>get</code>、<code>remove</code> 和 <code>insert</code> 元素提供了统一的命名方法。这些操作<strong>允许将链接列表用作堆栈、队列或双端队列</strong>。<br>此类实现 Deque 接口，为 <code>add</code>、<code>poll</code> 提供先进先出队列操作，以及其他堆栈和双端队列操作。<br>所有操作都是按照双重链接列表的需要执行的。<em>在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端)</em><br>注意，<strong>此实现不是同步的</strong>。如果多个线程同时访问一个链接列表，而其中至少一个线程从结构上修改了该列表，则它必须保持外部同步。</p>
</blockquote>
 <a id="more"></a>

<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector<E></E></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Vector 类可以实现可增长的对象数组</strong>。与数组一样，它包含可以使用整数索引进行访问的组件。但是，Vector 的大小可以根据需要增大或缩小，以适应创建 Vector 后进行添加或移除项的操作。<br>每个向量会试图通过维护 <code>capacity</code> 和 <code>capacityIncrement</code> 来优化存储管理。capacity 始终至少应与向量的大小相等；这个值通常比后者大些，因为随着将组件添加到向量中，其存储将按 capacityIncrement 的大小增加存储块。应用程序可以在插入大量组件前增加向量的容量；这样就减少了增加的重分配的量。<br><strong>Vector 是同步的</strong></p>
</blockquote>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><blockquote>
<p><strong>一个不包含重复元素的 collection</strong>。更确切地讲，set 不包含满足 <code>e1.equals(e2)</code> 的元素对 e1 和 e2，并且<strong>最多包含一个 null 元素</strong>。正如其名称所暗示的，此接口模仿了数学上的 set 抽象。</p>
</blockquote>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet<E></E></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。<strong>此类允许使用 null 元素</strong>。<br>此类为基本操作提供了稳定性能，这些基本操作包括 add、remove、contains 和 size，假定哈希函数将这些元素正确地分布在桶中。对此 set 进行迭代所需的时间与 HashSet 实例的大小（元素的数量）和底层 HashMap 实例（桶的数量）的“容量”的和成比例。<strong>因此，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）</strong>。<br>注意，<strong>此实现不是同步的</strong>。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须保持外部同步。</p>
</blockquote>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet<E></E></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，即<strong>按照将元素插入到 set 中的顺序（插入顺序）进行迭代</strong>。注意，插入顺序不 受在 set 中重新插入的 元素的影响。（如果在 s.contains(e) 返回 true 后立即调用 s.add(e)，则元素 e 会被重新插入到 set s 中。）</p>
</blockquote>
<p>此类提供所有可选的 Set 操作，并且允许 null 元素。与 HashSet 一样，它可以为基本操作（add、contains 和 remove）提供稳定的性能，假定哈希函数将元素正确地分布到存储段中。由于增加了维护链接列表的开支，其性能很可能会比 HashSet 稍逊一筹，不过，这一点例外：<strong>LinkedHashSet 迭代所需时间与 set 的大小 成正比，而与容量无关。HashSet 迭代很可能支出较大，因为它所需迭代时间与其容量 成正比</strong>。<br>链接的哈希 set 有两个影响其性能的参数：初始容量 和加载因子。它们与 HashSet 中的定义极其相同。注意，为初始容量选择非常高的值对此类的影响比对 HashSet 要小，因为此类的迭代时间不受容量的影响。<br>注意，<strong>此实现不是同步的</strong>。如果多个线程同时访问链接的哈希 set，而其中至少一个线程修改了该 set，则它必须 保持外部同步。</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet<E></E></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>基于 <code>TreeMap</code> 的 <code>NavigableSet</code> 实现。使用<strong>元素的自然顺序对元素进行排序</strong>，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。<br>此实现为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。<br>注意，如果要正确实现 Set 接口，则 set 维护的顺序（无论是否提供了显式比较器）必须与 equals 一致。（关于与 equals 一致 的精确定义，请参阅 Comparable 或 Comparator。）这是因为 Set 接口是按照 equals 操作定义的，但 TreeSet 实例使用它的 compareTo（或 compare）方法对所有元素进行比较，因此从 set 的观点来看，此方法认为相等的两个元素就是相等的。即使 set 的顺序与 equals 不一致，其行为也是 定义良好的；它只是违背了 Set 接口的常规协定。<br>注意，<strong>此实现不是同步的</strong>。如果多个线程同时访问一个 TreeSet，而其中至少一个线程修改了该 set，那么它必须 外部同步。</p>
</blockquote>
<h2 id="EnumSet-lt-E-extends-Enum-gt"><a href="#EnumSet-lt-E-extends-Enum-gt" class="headerlink" title="EnumSet&lt;E extends Enum&gt;"></a>EnumSet&lt;E extends Enum<E>&gt;</E></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>与枚举类型一起使用的专用 Set 实现。枚举 set 中所有键都必须来自单个枚举类型，该枚举类型在创建 set 时显式或隐式地指定。枚举 set 在内部表示为位向量。此表示形式非常紧凑且高效。此类的空间和时间性能应该很好，足以用作传统上基于 int 的“位标志”的替换形式，具有高品质、类型安全的优势。如果其参数也是一个枚举 set，则批量操作（如 containsAll 和 retainAll）也应运行得非常快。<br><strong>由 iterator 方法返回的迭代器按其自然顺序 遍历这些元素（该顺序是声明枚举常量的顺序）</strong>。返回的迭代器是弱一致的：它从不抛出 ConcurrentModificationException，也不一定显示在迭代进行时发生的任何 set 修改的效果。<br><strong>不允许使用 null 元素</strong>。试图插入 null 元素将抛出 NullPointerException。但是，试图测试是否出现 null 元素或移除 null 元素将不会抛出异常。<br>像大多数 collection 实现一样，<strong>EnumSet 是不同步的</strong>。如果多个线程同时访问一个枚举 set，并且至少有一个线程修改该 set，则此枚举 set 在外部应该是同步的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;MyEnum&gt; s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><blockquote>
<p>在处理元素前用于保存元素的 collection。除了基本的 Collection 操作外，队列还提供其他的插入、提取和检查操作。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是用于专门为有容量限制的 Queue 实现设计的；在大多数实现中，插入操作不会失败。</p>
</blockquote>
<h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque<E></E></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Deque 接口的大小可变数组的实现</strong>。数组双端队列没有容量限制；它们可根据需要增加以支持使用。它们<strong>不是线程安全的</strong>；在没有外部同步时，它们<strong>不支持多个线程的并发访问</strong>。<strong>禁止 null 元素</strong>。此类很可能在用作堆栈时快于 Stack，在用作队列时快于 LinkedList。<br>大多数 ArrayDeque 操作以摊销的固定时间运行。异常包括 <code>remove</code>、<code>removeFirstOccurrence</code>、<code>removeLastOccurrence</code>、<code>contains</code>、<code>iterator.remove()</code> 以及批量操作，它们均以<strong>线性时间运行</strong>。</p>
</blockquote>
<hr>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><blockquote>
<p>将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。<br>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的</p>
</blockquote>
<h2 id="HashMap-lt-K-V-gt"><a href="#HashMap-lt-K-V-gt" class="headerlink" title="HashMap&lt;K,V&gt;"></a>HashMap&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>基于哈希表的 Map 接口的实现</strong>。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（<strong>除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。</strong>）此类<strong>不保证映射的顺序</strong>，特别是它不保证该顺序恒久不变。<br>此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。<br>HashMap 的实例有两个参数影响其性能：<strong>初始容量</strong> 和<strong>加载因子</strong>。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子 (.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。<br>如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。<br>注意，<strong>此实现不是同步的</strong>。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须 保持外部同步。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap(...));</span><br></pre></td></tr></table></figure>
<h2 id="Hashtable-lt-K-V-gt"><a href="#Hashtable-lt-K-V-gt" class="headerlink" title="Hashtable&lt;K,V&gt;"></a>Hashtable&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此类实现一个哈希表，该哈希表将键映射到相应的值。任何<strong>非 null 对象都可以用作键或值</strong>。<br><strong>Hashtable 是同步的</strong></p>
</blockquote>
<h2 id="LinkedHashMap-lt-K-V-gt"><a href="#LinkedHashMap-lt-K-V-gt" class="headerlink" title="LinkedHashMap&lt;K,V&gt;"></a>LinkedHashMap&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Map 接口的哈希表和链接列表实现</strong>，具有<strong>可预知的迭代顺序</strong>。此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。注意，如果在映射中重新插入 键，则插入顺序不受影响。（如果在调用 m.put(k, v) 前 m.containsKey(k) 返回了 true，则调用时会将键 k 重新插入到映射 m 中。）<br>此实现可以让客户避免未指定的、由 HashMap（及 Hashtable）所提供的通常为杂乱无章的排序工作，同时无需增加与 TreeMap 相关的成本。使用它可以生成一个与原来顺序相同的映射副本，而与原映射的实现无关：<code>Map copy = new LinkedHashMap(m);</code><br>此类提供所有可选的 Map 操作，并且<strong>允许 null 元素</strong>。与 HashMap 一样，它可以为基本操作（add、contains 和 remove）提供稳定的性能，假定哈希函数将元素正确分布到桶中。由于增加了维护链接列表的开支，其性能很可能比 HashMap 稍逊一筹，不过这一点例外：LinkedHashMap 的 collection 视图迭代所需时间与映射的大小 成比例。HashMap 迭代时间很可能开支较大，因为它所需要的时间与其容量 成比例。<br>链接的哈希映射具有两个影响其性能的参数：<strong>初始容量</strong>和<strong>加载因子</strong>。它们的定义与 HashMap 极其相似。要注意，<strong>为初始容量选择非常高的值对此类的影响比对 HashMap 要小，因为此类的迭代时间不受容量的影响</strong>。<br>注意，<strong>此实现不是同步的</strong>。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须 保持外部同步。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(<span class="keyword">new</span> LinkedHashMap(...));</span><br></pre></td></tr></table></figure>
<h2 id="TreeMap-lt-K-V-gt"><a href="#TreeMap-lt-K-V-gt" class="headerlink" title="TreeMap&lt;K,V&gt;"></a>TreeMap&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>基于红黑树（Red-Black tree）的 NavigableMap 实现</strong>。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 <code>Comparator</code> 进行排序，具体取决于使用的构造方法。<br>此实现为 <code>containsKey</code>、<code>get</code>、<code>put</code> 和 <code>remove</code> 操作提供受保证的<strong>log(n)</strong>时间开销。这些算法是 Cormen、Leiserson 和 Rivest 的 Introduction to Algorithms 中的算法的改编。<br>注意，如果要正确实现 Map 接口，则有序映射所保持的顺序（无论是否明确提供了比较器）都必须与 equals 一致。（关于与 equals 一致 的精确定义，请参阅 Comparable 或 Comparator）。这是因为 Map 接口是按照 equals 操作定义的，但有序映射使用它的 compareTo（或 compare）方法对所有键进行比较，因此从有序映射的观点来看，此方法认为相等的两个键就是相等的。即使排序与 equals 不一致，有序映射的行为仍然是 定义良好的，只不过没有遵守 Map 接口的常规协定。<br>注意，<strong>此实现不是同步的</strong>。如果多个线程同时访问一个映射，并且其中至少一个线程从结构上修改了该映射，则其必须 外部同步。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SortedMap m = Collections.synchronizedSortedMap(<span class="keyword">new</span> TreeMap(...));</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>java语法</category>
      </categories>
      <tags>
        <tag>java语法</tag>
      </tags>
  </entry>
</search>
